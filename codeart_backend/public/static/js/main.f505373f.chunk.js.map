{"version":3,"sources":["components/Header/index.js","components/InputBoardButton/index.js","constants.js","components/InputBoard/index.js","components/OutputBoardFlap/index.js","components/OutputBoard/index.js","components/SplitflapDiagnostics/index.js","components/Main/index.js","index.js","../../ext/splitflap/software/js/splitflapjs-proto/dist/splitflap_proto.js"],"names":["Header","className","InputBoardButton","state","buttonOn","this","props","color","buttonValue","Component","apiURL","boxLayouts","position","symbol","gameDropDownList","value","label","InputBoard","handleDropDown","selectedOption","setState","console","log","fetch","method","body","JSON","stringify","game","headers","then","response","updateInputBoardLayout","i","boardSymbols","map","item","j","boardColors","createInputGrid","table","length","push","key","buttonID","socket","numberOfUsers","Array","fill","on","data","buttons","customStyles","menu","provided","zIndex","styles","onChange","options","placeholder","SPLITFLAP_ERROR_STATES","PB","SplitflapState","ModuleState","State","SENSOR_ERROR","PANIC","STATE_DISABLED","flapLayouts","OutputBoardFlap","text","classes","tooltip","undefined","flapIndex","countMissedHome","countUnexpectedHome","LOOK_FOR_HOME","indexOf","toObject","enums","String","join","title","onClick","onResetModule","OutputBoard","createOutputGrid","rows","splitflapState","modules","slice","row","y","x","p","PowerChannel","voltageVolts","toFixed","currentAmps","SplitflapDiagnostics","supervisorState","onSupervisorState","onSplitflapState","off","supervisorStateObj","SupervisorState","defaults","serverName","onHardResetClick","uptimeMillis","style","display","FAULT","faultInfo","powerChannels","d","stopAnimation","a","startAnimation","Main","boardLayoutData","onBoardLayoutUpdate","flaps","resetModule","io","uri","splitflapHardReset","backendHost","socketIOClient","URL","result","alert","animation","ReactDOM","render","StrictMode","id","document","getElementById","define","$protobuf","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","properties","keys","Object","prototype","emptyArray","create","encode","message","writer","uint32","fork","ldelim","encodeDelimited","decode","reader","end","len","pos","tag","skipType","decodeDelimited","verify","hasOwnProperty","isArray","error","fromObject","object","TypeError","arrays","toJSON","constructor","toJSONOptions","moving","homeState","call","int32","bool","isInteger","Boolean","valuesById","values","Log","msg","string","isString","Ack","nonce","PowerChannelState","FaultInfo","float","Number","json","isFinite","type","tsMillis","FaultType","FromSplitflap","$oneOfFields","ack","defineProperty","get","oneOfGetter","set","oneOfSetter","payload","oneofs","SplitflapCommand","ModuleCommand","action","param","Action","SplitflapConfig","ModuleConfig","targetFlapIndex","movementNonce","resetNonce","ToSplitflap","splitflapCommand","splitflapConfig"],"mappings":"0PAWeA,MARf,WACE,OACE,yBAAKC,UAAU,UAAf,kB,QCuBWC,G,8DAxBX,aAAe,IAAD,8BACV,gBACKC,MAAQ,CACTC,UAAU,GAHJ,E,qDASV,OACI,yBACIH,UAAS,6BAAwBI,KAAKC,MAAMC,QAO3CF,KAAKC,MAAME,iB,GAnBGC,c,QCHlBC,EAAS,wBCQhBC,EAAa,CACf,CAACC,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,QAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,QAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,SAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,QAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,QAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,SAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,SAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,SAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAElC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,UAClC,CAACK,SAAU,EAAGC,OAAQ,IAAKN,MAAO,SAElC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,QAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,SAEnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UACnC,CAACK,SAAU,GAAIC,OAAQ,IAAKN,MAAO,UAKjCO,EAAmB,CACvB,CAAEC,MAAO,IAAKC,MAAO,4FACrB,CAAED,MAAO,IAAKC,MAAO,+DACrB,CAAED,MAAO,IAAKC,MAAO,gEACrB,CAAED,MAAO,IAAKC,MAAO,8FACrB,CAAED,MAAO,IAAKC,MAAO,8FACrB,CAAED,MAAO,IAAKC,MAAO,mFACrB,CAAED,MAAO,IAAKC,MAAO,mEACrB,CAAED,MAAO,IAAKC,MAAO,+DACrB,CAAED,MAAO,IAAKC,MAAO,qFACrB,CAAED,MAAO,IAAKC,MAAO,8FA4IRC,E,kDAtIX,aAAe,IAAD,8BACV,gBAUJC,eAAgB,SAACC,GACf,EAAKC,SAAS,CAAED,mBAChBE,QAAQC,IAAR,mBAAgCH,EAAeJ,OAC/CQ,MAAM,GAAD,OAAIb,EAAJ,SAAmB,CAGtBc,OAAQ,OAERC,KAAMC,KAAKC,UAAU,CACjBC,KAAMT,EAAeJ,QAGzBc,QAAS,CACL,eAAgB,qCAErBC,MAAK,SAACC,GAAD,OAAcV,QAAQC,IAAIS,OA1BpB,EA6CdC,uBAAyB,SAAAC,GACrB,EAAKb,UAAS,SAAAjB,GA8BZ,MAAO,CACL+B,aA7BkB/B,EAAM+B,aAAaC,KAAI,SAACC,EAAMC,GAEhD,OAAS,MAALJ,GAAaI,IAAM1B,EAAWsB,GAAGrB,UAAYwB,IAASzB,EAAWsB,GAAGpB,OAC/DF,EAAWsB,GAAGpB,OAEV,MAALoB,GAAaI,IAAM1B,EAAWsB,GAAGrB,UAAawB,IAASzB,EAAWsB,GAAGpB,OACpE,IAIEuB,KAoBXE,YAhBkBnC,EAAMmC,YAAYH,KAAI,SAACC,EAAMC,GAE/C,OAAS,MAALJ,GAAaI,IAAM1B,EAAWsB,GAAGrB,UAAYwB,IAASzB,EAAWsB,GAAG1B,MAC/DI,EAAWsB,GAAG1B,MAEV,MAAL0B,GAAaI,IAAM1B,EAAWsB,GAAGrB,UAAawB,IAASzB,EAAWsB,GAAG1B,MACpE,QAIE6B,UAxEL,EAmFdG,gBAAkB,WAGd,IAFA,IAAIC,EAAQ,GAEHP,EAAI,EAAGA,EAAI,EAAK9B,MAAM+B,aAAaO,OAAQR,IAChDO,EAAME,KACF,kBAAC,EAAD,CACIC,IAAKV,EACLW,SAAUX,EACVzB,YAAa,EAAKL,MAAM+B,aAAaD,GACrCY,OAAQ,EAAKvC,MAAMuC,OACnBtC,MAAO,EAAKJ,MAAMmC,YAAYL,MAI1C,OAAOO,GA/FP,EAAKrC,MAAQ,CACT2C,cAAe,EACfZ,aAAca,MAAM,IAAIC,KAAK,KAC7BV,YAAaS,MAAM,IAAIC,KAAK,SAC5B7B,eAAgB,MANV,E,gEA6BO,IAAD,OAChBd,KAAKC,MAAMuC,OAAOI,GAAG,mBAAmB,SAACC,GACrC,EAAK9B,SAAS,CAAE0B,cAAeI,EAAKJ,mBAGxCzC,KAAKC,MAAMuC,OAAOI,GAAG,eAAe,SAACC,GACjC7B,QAAQC,IAAI,cAAe4B,GAC3B,EAAKlB,uBAAuBkB,EAAKC,YAGrC9C,KAAKC,MAAMuC,OAAOI,GAAG,aAAa,SAACC,GAC/B,EAAKlB,uBAAuBkB,EAAKC,c,+BA4D/B,IACAhC,EAAmBd,KAAKF,MAAxBgB,eAEFiC,EAAe,CACnBC,KAAM,SAACC,EAAUnD,GAAX,sBACDmD,EADC,CAGJC,OAAQ,QAMV,OACI,yBAAKtD,UAAU,yBACX,yBAAKA,UAAU,qBAAf,mBACmBI,KAAKF,MAAM2C,eAE9B,yBAAK7C,UAAU,2BACb,kBAAC,IAAD,CACEuD,OAAQJ,EACRrC,MAAOI,EACPsC,SAAUpD,KAAKa,eACfwC,QAAS5C,EACT6C,YAAa,mBAGjB,yBAAK1D,UAAU,eACVI,KAAKkC,wB,GAjID9B,a,qBC7FnBmD,EAAyB,CAC3BC,KAAGC,eAAeC,YAAYC,MAAMC,aACpCJ,KAAGC,eAAeC,YAAYC,MAAME,MACpCL,KAAGC,eAAeC,YAAYC,MAAMG,gBAGlCC,EAAc,CAChB,CAACvD,OAAQ,IAAKN,MAAO,eACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,UACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,QACrB,CAACM,OAAQ,IAAKN,MAAO,UACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,SACrB,CAACM,OAAQ,IAAKN,MAAO,UAmDV8D,E,uKA7CP,IAAMnB,EAAO7C,KAAKC,MAAM4C,KACpBoB,EAAO,GACLC,EAAU,CAAC,qBACbC,EAAU,QAEDC,IAATvB,IACAoB,EAAOF,EAAYlB,EAAKwB,WAAW7D,OACnC0D,EAAQ7B,KAAR,4BAAkC0B,EAAYlB,EAAKwB,WAAWnE,cAGpBkE,IAAzBvB,EAAKyB,iBAAiCzB,EAAKyB,gBAAkB,QACzCF,IAA7BvB,EAAK0B,qBAAqC1B,EAAK0B,oBAAsB,QACtDH,IAAfvB,EAAK/C,OAAuB+C,EAAK/C,QAAU0D,KAAGC,eAAeC,YAAYC,MAAMa,gBAEnFN,EAAQ7B,KAAK,2BAGY+B,IAAfvB,EAAK/C,QAAuE,IAAhDyD,EAAuBkB,QAAQ5B,EAAK/C,QAE1EoE,EAAQ7B,KAAK,yBAGE+B,IAAfvB,EAAK/C,OACLqE,EAAQ9B,KAAR,iBAAuBmB,KAAGC,eAAeC,YAAYgB,SAAS7B,EAAM,CAAC8B,MAAOC,SAAS9E,aAE5DsE,IAAzBvB,EAAKyB,iBACLH,EAAQ9B,KAAR,uBAA6BQ,EAAKyB,uBAELF,IAA7BvB,EAAK0B,qBACLJ,EAAQ9B,KAAR,2BAAiCQ,EAAK0B,sBAE1CJ,EAAQ9B,KAAK,qBAGjB,OACI,wBACIzC,UAAWsE,EAAQW,KAAK,KACxBC,MAAOX,EAAQU,KAAK,QACpBE,QAAS/E,KAAKC,MAAM+E,eAEnBf,O,GA1Ca7D,aCXf6E,E,4MAxCXC,iBAAmB,WAIf,IAHA,IAAIC,EAAO,GAEPvD,EAAI,EACDA,EAAI,EAAK3B,MAAMmF,eAAeC,QAAQjD,QACzC+C,EAAK9C,KAAK,EAAKpC,MAAMmF,eAAeC,QAAQC,MAAM1D,EAAGA,GAAK,KAG9D,OAAOuD,EAAKrD,KAAI,SAACyD,EAAKC,GAAN,OACZ,wBAAIlD,IAAKkD,GAEDD,EAAIzD,KAAI,SAACC,EAAM0D,GACX,IAAIC,EAAI,GAIR,OAHI,EAAKzF,MAAM+E,gBACXU,EAAC,cAAoB,WAAQ,EAAKzF,MAAM+E,cAAcS,EAAGD,KAG7D,kBAAC,EAAD,eACI3C,KAAMd,EACNO,IAAG,UAAKmD,EAAL,YAAUD,IACTE,Y,uDASxB,OACI,yBAAK9F,UAAU,0BACX,2BAAOA,UAAU,gBACb,+BACKI,KAAKkF,0B,GAlCJ9E,aCApBuF,G,MAAe,SAAC1F,GAClB,OACI,yBAAKL,UAAU,iBACX,yBAAKA,UAAS,2BAAsBK,EAAM4C,KAAKD,KAAO3C,EAAM4C,KAAKD,GAAK,KAAO,OAC7E,yBAAKhD,UAAU,WAAWK,EAAM4C,KAAK+C,aAAaC,QAAQ,GAA1D,MACA,yBAAKjG,UAAU,WAAWK,EAAM4C,KAAKiD,YAAYD,QAAQ,GAAzD,SAwDGE,E,kDAlDX,aAAe,IAAD,8BACV,gBACKjG,MAAQ,CACTkG,gBAAiB,IAHX,E,8DAOIlG,GACdE,KAAKe,SAAS,CAACiF,gBAAiBlG,M,uCAGnBA,GACbE,KAAKe,SAAS,CAACqE,eAAgBtF,M,0CAGd,IAAD,OAChBE,KAAKC,MAAMuC,OAAOI,GAAG,8BAA8B,SAACC,GAAU,EAAKoD,kBAAkBpD,MACrF7C,KAAKC,MAAMuC,OAAOI,GAAG,mBAAmB,SAACC,GAAU,EAAKqD,iBAAiBrD,Q,6CAIzE7C,KAAKC,MAAMuC,OAAO2D,IAAI,6BAA8BnG,KAAKiG,mBACzDjG,KAAKC,MAAMuC,OAAO2D,IAAI,kBAAmBnG,KAAKkG,oB,+BAGxC,IAAD,OACCE,EAAqB5C,KAAG6C,gBAAgB3B,SAAS1E,KAAKF,MAAMkG,gBAAiB,CAACM,UAAS,EAAM3B,MAAOC,SAC1G,OACI,yBAAKhF,UAAU,eACX,wCAAcI,KAAKC,MAAMsG,YACzB,6BAAK,4BAAQxB,QAAS/E,KAAKC,MAAMuG,kBAA5B,6BACL,wCAAcxG,KAAKF,MAAMkG,gBAAgBS,cACzC,+CAAqBL,EAAmBtG,OACxC,yBAAK4G,MAAO,CAACC,QAAS3G,KAAKF,MAAMkG,gBAAgBlG,QAAU0D,KAAG6C,gBAAgB1C,MAAMiD,MAAQ,QAAU,SAAtG,cAA0H,6BAAMvF,KAAKC,UAAU8E,EAAmBS,eAAWzC,EAAW,KAEpLgC,EAAmBU,cAAchF,KAAI,SAACiF,EAAGnF,GAAJ,OAAW,kBAAC,EAAD,CAAciB,KAAMkE,EAAGzE,IAAKV,OAEhF,6BACI,4BAAQmD,QAAS/E,KAAKC,MAAM+G,eAA5B,QAEI,CAAC,UAAW,UAAW,OAAQ,SAAU,aAAc,YAAa,kBAAkBlF,KAAI,SAACmF,GAAD,OACtF,4BAAQlC,QAAS,kBAAM,EAAK9E,MAAMiH,eAAeD,IAAI3E,IAAK2E,GAAIA,Y,GA1CvD7G,aCiDpB+G,E,kDAtDX,aAAe,IAAD,8BACV,gBACKrH,MAAQ,CACTsH,gBAAiB,CACb/B,QAAS3C,MAAM,KAAKC,UAAKyB,IAE7BgB,eAAgB,CACZC,QAAS3C,MAAM,KAAKC,UAAKyB,KAPvB,E,gEAYMvB,GAChB7C,KAAKe,SAAS,CACVqG,gBAAiB,CACb/B,QAASxC,EAAKf,KAAI,SAACF,GACf,MAAO,CACHyC,UAAWzC,W,0CAOV,IAAD,OAChB5B,KAAKC,MAAMuC,OAAOI,GAAG,eAAe,SAACC,GACjC7B,QAAQC,IAAI,cAAe4B,GAC3B,EAAKwE,oBAAoBxE,EAAKyE,UAGlCtH,KAAKC,MAAMuC,OAAOI,GAAG,aAAa,SAACC,GAC/B,EAAKwE,oBAAoBxE,EAAKyE,UAGlCtH,KAAKC,MAAMuC,OAAOI,GAAG,mBAAmB,SAACC,GAAU,EAAK9B,SAAS,CAACqE,eAAgBvC,S,6CAIlF7C,KAAKC,MAAMuC,OAAO2D,IAAI,kBAAmBnG,KAAKkG,oB,+BAI9C,OACI,6BACI,kBAAC,EAAD,MACA,kBAAC,EAAD,CAAY1D,OAAQxC,KAAKC,MAAMuC,SAC/B,kBAAC,EAAD,CAAaA,OAAQxC,KAAKC,MAAMuC,OAAQ4C,eAAgBpF,KAAKF,MAAMsH,kBACnE,kBAAC,EAAD,CAAa5E,OAAQxC,KAAKC,MAAMuC,OAAQ4C,eAAgBpF,KAAKF,MAAMsF,eAAgBJ,cAAehF,KAAKC,MAAMsH,cAE7G,kBAAC,EAAD,CAAsBhB,WAAYvG,KAAKC,MAAMuC,OAAOgF,GAAGC,IAAKjF,OAAQxC,KAAKC,MAAMuC,OAAQgE,iBAAkBxG,KAAKC,MAAMyH,mBAAoBR,eAAgBlH,KAAKC,MAAMiH,eAAgBF,cAAehH,KAAKC,MAAM+G,qB,GAlD1M5G,a,gBCCbuH,EAActH,EAGdmC,E,MAASoF,GAAeD,GAIxBD,EAAkB,uCAAG,4BAAAT,EAAA,+EAEF/F,MAAM,IAAI2G,IAAI,wBAAyBF,GAAc,CACxExG,OAAQ,SAHa,cAEjB2G,EAFiB,YAKvBC,MALuB,SAKXD,EAAO7D,OALI,oFAOvB8D,MAAM,EAAD,IAPkB,0DAAH,qDAWlBR,EAAW,uCAAG,WAAO9B,EAAGD,GAAV,eAAAyB,EAAA,+EAEK/F,MAAM,IAAI2G,IAAI,0BAA2BF,GAAc,CAC1ExG,OAAQ,OACRK,QAAS,CACP,OAAU,mBACV,eAAgB,oBAElBJ,KAAMC,KAAKC,UAAU,CAACmE,IAAGD,QARX,cAEVsC,EAFU,YAUhB9G,QAVgB,sCAU0B8G,EAAO7D,OAVjC,yDAURhD,IAVQ,kEAYhB8G,MAAM,EAAD,IAZW,0DAAH,wDAgBXb,EAAc,uCAAG,WAAOc,GAAP,eAAAf,EAAA,+EAEE/F,MAAM,IAAI2G,IAAI,6BAA8BF,GAAc,CAC7ExG,OAAQ,OACRK,QAAS,CACP,OAAU,mBACV,eAAgB,oBAElBJ,KAAMC,KAAKC,UAAU,CAAC0G,gBARL,cAEbF,EAFa,YAUnB9G,QAVmB,yCAU0B8G,EAAO7D,OAVjC,yDAUXhD,IAVW,kEAYnB8G,MAAM,EAAD,IAZc,0DAAH,sDAgBdf,EAAa,uCAAG,4BAAAC,EAAA,+EAEG/F,MAAM,IAAI2G,IAAI,4BAA6BF,GAAc,CAC5ExG,OAAQ,SAHQ,cAEZ2G,EAFY,YAKlB9G,QALkB,wCAK0B8G,EAAO7D,OALjC,yDAKVhD,IALU,kEAOlB8G,MAAM,EAAD,IAPa,0DAAH,qDAWnBE,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,yBAAKC,GAAG,eACN,kBAAC,EAAD,CAAM5F,OAAQA,EAAQkF,mBAAoBA,EAAoBH,YAAaA,EAAaL,eAAgBA,EAAgBF,cAAeA,MAG3IqB,SAASC,eAAe,U,uDC5E1B,UAIQC,EAAO,CAAC,YAAF,6BAKL,SAASC,GACd,aAGA,IAAIC,EAAUD,EAAUE,OAAQC,EAAUH,EAAUI,OAAQC,EAAQL,EAAUM,KAG1EC,EAAQP,EAAUQ,MAAV,UAA+BR,EAAUQ,MAAV,QAA6B,IA6tGxE,OA3tGAD,EAAMvF,GAAM,WAOR,IAAIA,EAAK,GAitGT,OA/sGAA,EAAGC,eAAkB,WAiBjB,SAASA,EAAewF,GAEpB,GADAjJ,KAAKqF,QAAU,GACX4D,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAihBhD,OAxgBA6B,EAAe2F,UAAU/D,QAAUwD,EAAMQ,WAUzC5F,EAAe6F,OAAS,SAAgBL,GACpC,OAAO,IAAIxF,EAAewF,IAY9BxF,EAAe8F,OAAS,SAAgBC,EAASC,GAG7C,GAFKA,IACDA,EAASd,EAAQW,UACE,MAAnBE,EAAQnE,SAAmBmE,EAAQnE,QAAQjD,OAC3C,IAAK,IAAIR,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAC1CmH,EAAMvF,GAAGC,eAAeC,YAAY6F,OAAOC,EAAQnE,QAAQzD,GAAI6H,EAAOC,OAA8B,IAAIC,QAAQC,SACxH,OAAOH,GAYXhG,EAAeoG,gBAAkB,SAAyBL,EAASC,GAC/D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCnG,EAAeqG,OAAS,SAAgBC,EAAQ3H,GACtC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGC,eACnFsG,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACKX,EAAQnE,SAAWmE,EAAQnE,QAAQjD,SACrCoH,EAAQnE,QAAU,IACtBmE,EAAQnE,QAAQhD,KAAK0G,EAAMvF,GAAGC,eAAeC,YAAYoG,OAAOC,EAAQA,EAAOL,WAC/E,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaX/F,EAAe4G,gBAAkB,SAAyBN,GAGtD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCjG,EAAe6G,OAAS,SAAgBd,GACpC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAuB,MAAnBA,EAAQnE,SAAmBmE,EAAQe,eAAe,WAAY,CAC9D,IAAK7H,MAAM8H,QAAQhB,EAAQnE,SACvB,MAAO,0BACX,IAAK,IAAIzD,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAAG,CAC7C,IAAI6I,EAAQ1B,EAAMvF,GAAGC,eAAeC,YAAY4G,OAAOd,EAAQnE,QAAQzD,IACvE,GAAI6I,EACA,MAAO,WAAaA,GAGhC,OAAO,MAWXhH,EAAeiH,WAAa,SAAoBC,GAC5C,GAAIA,aAAkB5B,EAAMvF,GAAGC,eAC3B,OAAOkH,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGC,eAC3B,GAAIkH,EAAOtF,QAAS,CAChB,IAAK3C,MAAM8H,QAAQG,EAAOtF,SACtB,MAAMuF,UAAU,8CACpBpB,EAAQnE,QAAU,GAClB,IAAK,IAAIzD,EAAI,EAAGA,EAAI+I,EAAOtF,QAAQjD,SAAUR,EAAG,CAC5C,GAAiC,kBAAtB+I,EAAOtF,QAAQzD,GACtB,MAAMgJ,UAAU,+CACpBpB,EAAQnE,QAAQzD,GAAKmH,EAAMvF,GAAGC,eAAeC,YAAYgH,WAAWC,EAAOtF,QAAQzD,KAG3F,OAAO4H,GAYX/F,EAAeiB,SAAW,SAAkB8E,EAASnG,GAC5CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAGb,IAFItH,EAAQwH,QAAUxH,EAAQiD,YAC1BqE,EAAOtF,QAAU,IACjBmE,EAAQnE,SAAWmE,EAAQnE,QAAQjD,OAAQ,CAC3CuI,EAAOtF,QAAU,GACjB,IAAK,IAAIrD,EAAI,EAAGA,EAAIwH,EAAQnE,QAAQjD,SAAUJ,EAC1C2I,EAAOtF,QAAQrD,GAAK+G,EAAMvF,GAAGC,eAAeC,YAAYgB,SAAS8E,EAAQnE,QAAQrD,GAAIqB,GAE7F,OAAOsH,GAUXlH,EAAe2F,UAAU0B,OAAS,WAC9B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAG1DvH,EAAeC,YAAe,WAsB1B,SAASA,EAAYuF,GACjB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA6ThD,OApTA8B,EAAY0F,UAAUtJ,MAAQ,EAQ9B4D,EAAY0F,UAAU/E,UAAY,EAQlCX,EAAY0F,UAAU6B,QAAS,EAQ/BvH,EAAY0F,UAAU8B,WAAY,EAQlCxH,EAAY0F,UAAU7E,oBAAsB,EAQ5Cb,EAAY0F,UAAU9E,gBAAkB,EAUxCZ,EAAY4F,OAAS,SAAgBL,GACjC,OAAO,IAAIvF,EAAYuF,IAY3BvF,EAAY6F,OAAS,SAAgBC,EAASC,GAe1C,OAdKA,IACDA,EAASd,EAAQW,UACA,MAAjBE,EAAQ1J,OAAiBqJ,OAAOoB,eAAeY,KAAK3B,EAAS,UAC7DC,EAAOC,OAA8B,GAAG0B,MAAM5B,EAAQ1J,OACjC,MAArB0J,EAAQnF,WAAqB8E,OAAOoB,eAAeY,KAAK3B,EAAS,cACjEC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQnF,WACtC,MAAlBmF,EAAQyB,QAAkB9B,OAAOoB,eAAeY,KAAK3B,EAAS,WAC9DC,EAAOC,OAA8B,IAAI2B,KAAK7B,EAAQyB,QACjC,MAArBzB,EAAQ0B,WAAqB/B,OAAOoB,eAAeY,KAAK3B,EAAS,cACjEC,EAAOC,OAA8B,IAAI2B,KAAK7B,EAAQ0B,WACvB,MAA/B1B,EAAQjF,qBAA+B4E,OAAOoB,eAAeY,KAAK3B,EAAS,wBAC3EC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQjF,qBAC7B,MAA3BiF,EAAQlF,iBAA2B6E,OAAOoB,eAAeY,KAAK3B,EAAS,oBACvEC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQlF,iBACrDmF,GAYX/F,EAAYmG,gBAAkB,SAAyBL,EAASC,GAC5D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxClG,EAAYoG,OAAS,SAAgBC,EAAQ3H,GACnC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGC,eAAeC,YAClGqG,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQ1J,MAAQiK,EAAOqB,QACvB,MACJ,KAAK,EACD5B,EAAQnF,UAAY0F,EAAOL,SAC3B,MACJ,KAAK,EACDF,EAAQyB,OAASlB,EAAOsB,OACxB,MACJ,KAAK,EACD7B,EAAQ0B,UAAYnB,EAAOsB,OAC3B,MACJ,KAAK,EACD7B,EAAQjF,oBAAsBwF,EAAOL,SACrC,MACJ,KAAK,EACDF,EAAQlF,gBAAkByF,EAAOL,SACjC,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaX9F,EAAY2G,gBAAkB,SAAyBN,GAGnD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtChG,EAAY4G,OAAS,SAAgBd,GACjC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAqB,MAAjBA,EAAQ1J,OAAiB0J,EAAQe,eAAe,SAChD,OAAQf,EAAQ1J,OAChB,QACI,MAAO,6BACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAGT,OAAyB,MAArB0J,EAAQnF,WAAqBmF,EAAQe,eAAe,eAC/C1B,EAAMyC,UAAU9B,EAAQnF,WAClB,8BACO,MAAlBmF,EAAQyB,QAAkBzB,EAAQe,eAAe,WACnB,mBAAnBf,EAAQyB,OACR,2BACU,MAArBzB,EAAQ0B,WAAqB1B,EAAQe,eAAe,cACnB,mBAAtBf,EAAQ0B,UACR,8BACoB,MAA/B1B,EAAQjF,qBAA+BiF,EAAQe,eAAe,yBACzD1B,EAAMyC,UAAU9B,EAAQjF,qBAClB,wCACgB,MAA3BiF,EAAQlF,iBAA2BkF,EAAQe,eAAe,qBACrD1B,EAAMyC,UAAU9B,EAAQlF,iBAClB,oCACR,MAWXZ,EAAYgH,WAAa,SAAoBC,GACzC,GAAIA,aAAkB5B,EAAMvF,GAAGC,eAAeC,YAC1C,OAAOiH,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGC,eAAeC,YAC1C,OAAQiH,EAAO7K,OACf,IAAK,SACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,gBACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,eACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,QACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,iBACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAapB,OAVwB,MAApB6K,EAAOtG,YACPmF,EAAQnF,UAAYsG,EAAOtG,YAAc,GACxB,MAAjBsG,EAAOM,SACPzB,EAAQyB,OAASM,QAAQZ,EAAOM,SACZ,MAApBN,EAAOO,YACP1B,EAAQ0B,UAAYK,QAAQZ,EAAOO,YACL,MAA9BP,EAAOpG,sBACPiF,EAAQjF,oBAAsBoG,EAAOpG,sBAAwB,GACnC,MAA1BoG,EAAOrG,kBACPkF,EAAQlF,gBAAkBqG,EAAOrG,kBAAoB,GAClDkF,GAYX9F,EAAYgB,SAAW,SAAkB8E,EAASnG,GACzCA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAqBb,OApBItH,EAAQiD,WACRqE,EAAO7K,MAAQuD,EAAQsB,QAAUC,OAAS,SAAW,EACrD+F,EAAOtG,UAAY,EACnBsG,EAAOM,QAAS,EAChBN,EAAOO,WAAY,EACnBP,EAAOpG,oBAAsB,EAC7BoG,EAAOrG,gBAAkB,GAER,MAAjBkF,EAAQ1J,OAAiB0J,EAAQe,eAAe,WAChDI,EAAO7K,MAAQuD,EAAQsB,QAAUC,OAASmE,EAAMvF,GAAGC,eAAeC,YAAYC,MAAM6F,EAAQ1J,OAAS0J,EAAQ1J,OACxF,MAArB0J,EAAQnF,WAAqBmF,EAAQe,eAAe,eACpDI,EAAOtG,UAAYmF,EAAQnF,WACT,MAAlBmF,EAAQyB,QAAkBzB,EAAQe,eAAe,YACjDI,EAAOM,OAASzB,EAAQyB,QACH,MAArBzB,EAAQ0B,WAAqB1B,EAAQe,eAAe,eACpDI,EAAOO,UAAY1B,EAAQ0B,WACI,MAA/B1B,EAAQjF,qBAA+BiF,EAAQe,eAAe,yBAC9DI,EAAOpG,oBAAsBiF,EAAQjF,qBACV,MAA3BiF,EAAQlF,iBAA2BkF,EAAQe,eAAe,qBAC1DI,EAAOrG,gBAAkBkF,EAAQlF,iBAC9BqG,GAUXjH,EAAY0F,UAAU0B,OAAS,WAC3B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAa1DtH,EAAYC,MAAS,WACjB,IAAI6H,EAAa,GAAIC,EAAStC,OAAOG,OAAOkC,GAM5C,OALAC,EAAOD,EAAW,GAAK,UAAY,EACnCC,EAAOD,EAAW,GAAK,iBAAmB,EAC1CC,EAAOD,EAAW,GAAK,gBAAkB,EACzCC,EAAOD,EAAW,GAAK,SAAW,EAClCC,EAAOD,EAAW,GAAK,kBAAoB,EACpCC,EAPU,GAUd/H,EAvVmB,GA0VvBD,EAviBU,GA0iBrBD,EAAGkI,IAAO,WAiBN,SAASA,EAAIzC,GACT,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAmKhD,OA1JA8J,EAAItC,UAAUuC,IAAM,GAUpBD,EAAIpC,OAAS,SAAgBL,GACzB,OAAO,IAAIyC,EAAIzC,IAYnByC,EAAInC,OAAS,SAAgBC,EAASC,GAKlC,OAJKA,IACDA,EAASd,EAAQW,UACF,MAAfE,EAAQmC,KAAexC,OAAOoB,eAAeY,KAAK3B,EAAS,QAC3DC,EAAOC,OAA8B,IAAIkC,OAAOpC,EAAQmC,KACrDlC,GAYXiC,EAAI7B,gBAAkB,SAAyBL,EAASC,GACpD,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxC8B,EAAI5B,OAAS,SAAgBC,EAAQ3H,GAC3B2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGkI,IACnF3B,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQmC,IAAM5B,EAAO6B,SACrB,MACJ,QACI7B,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXkC,EAAIrB,gBAAkB,SAAyBN,GAG3C,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCgC,EAAIpB,OAAS,SAAgBd,GACzB,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACQ,MAAfA,EAAQmC,KAAenC,EAAQe,eAAe,SACzC1B,EAAMgD,SAASrC,EAAQmC,KACjB,uBACR,MAWXD,EAAIhB,WAAa,SAAoBC,GACjC,GAAIA,aAAkB5B,EAAMvF,GAAGkI,IAC3B,OAAOf,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGkI,IAG3B,OAFkB,MAAdf,EAAOgB,MACPnC,EAAQmC,IAAM/G,OAAO+F,EAAOgB,MACzBnC,GAYXkC,EAAIhH,SAAW,SAAkB8E,EAASnG,GACjCA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAKb,OAJItH,EAAQiD,WACRqE,EAAOgB,IAAM,IACE,MAAfnC,EAAQmC,KAAenC,EAAQe,eAAe,SAC9CI,EAAOgB,IAAMnC,EAAQmC,KAClBhB,GAUXe,EAAItC,UAAU0B,OAAS,WACnB,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnDU,EAxLD,GA2LVlI,EAAGsI,IAAO,WAiBN,SAASA,EAAI7C,GACT,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAmKhD,OA1JAkK,EAAI1C,UAAU2C,MAAQ,EAUtBD,EAAIxC,OAAS,SAAgBL,GACzB,OAAO,IAAI6C,EAAI7C,IAYnB6C,EAAIvC,OAAS,SAAgBC,EAASC,GAKlC,OAJKA,IACDA,EAASd,EAAQW,UACA,MAAjBE,EAAQuC,OAAiB5C,OAAOoB,eAAeY,KAAK3B,EAAS,UAC7DC,EAAOC,OAA8B,GAAGA,OAAOF,EAAQuC,OACpDtC,GAYXqC,EAAIjC,gBAAkB,SAAyBL,EAASC,GACpD,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCkC,EAAIhC,OAAS,SAAgBC,EAAQ3H,GAC3B2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGsI,IACnF/B,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQuC,MAAQhC,EAAOL,SACvB,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXsC,EAAIzB,gBAAkB,SAAyBN,GAG3C,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCoC,EAAIxB,OAAS,SAAgBd,GACzB,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACU,MAAjBA,EAAQuC,OAAiBvC,EAAQe,eAAe,WAC3C1B,EAAMyC,UAAU9B,EAAQuC,OAClB,0BACR,MAWXD,EAAIpB,WAAa,SAAoBC,GACjC,GAAIA,aAAkB5B,EAAMvF,GAAGsI,IAC3B,OAAOnB,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGsI,IAG3B,OAFoB,MAAhBnB,EAAOoB,QACPvC,EAAQuC,MAAQpB,EAAOoB,QAAU,GAC9BvC,GAYXsC,EAAIpH,SAAW,SAAkB8E,EAASnG,GACjCA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAKb,OAJItH,EAAQiD,WACRqE,EAAOoB,MAAQ,GACE,MAAjBvC,EAAQuC,OAAiBvC,EAAQe,eAAe,WAChDI,EAAOoB,MAAQvC,EAAQuC,OACpBpB,GAUXmB,EAAI1C,UAAU0B,OAAS,WACnB,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnDc,EAxLD,GA2LVtI,EAAG6C,gBAAmB,WAoBlB,SAASA,EAAgB4C,GAErB,GADAjJ,KAAK8G,cAAgB,GACjBmC,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAk0BhD,OAzzBAyE,EAAgB+C,UAAU3C,aAAe,EAQzCJ,EAAgB+C,UAAUtJ,MAAQ,EAQlCuG,EAAgB+C,UAAUtC,cAAgB+B,EAAMQ,WAQhDhD,EAAgB+C,UAAUvC,UAAY,KAUtCR,EAAgBiD,OAAS,SAAgBL,GACrC,OAAO,IAAI5C,EAAgB4C,IAY/B5C,EAAgBkD,OAAS,SAAgBC,EAASC,GAO9C,GANKA,IACDA,EAASd,EAAQW,UACO,MAAxBE,EAAQ/C,cAAwB0C,OAAOoB,eAAeY,KAAK3B,EAAS,iBACpEC,EAAOC,OAA8B,GAAGA,OAAOF,EAAQ/C,cACtC,MAAjB+C,EAAQ1J,OAAiBqJ,OAAOoB,eAAeY,KAAK3B,EAAS,UAC7DC,EAAOC,OAA8B,IAAI0B,MAAM5B,EAAQ1J,OAC9B,MAAzB0J,EAAQ1C,eAAyB0C,EAAQ1C,cAAc1E,OACvD,IAAK,IAAIR,EAAI,EAAGA,EAAI4H,EAAQ1C,cAAc1E,SAAUR,EAChDmH,EAAMvF,GAAG6C,gBAAgB2F,kBAAkBzC,OAAOC,EAAQ1C,cAAclF,GAAI6H,EAAOC,OAA8B,IAAIC,QAAQC,SAGrI,OAFyB,MAArBJ,EAAQ3C,WAAqBsC,OAAOoB,eAAeY,KAAK3B,EAAS,cACjET,EAAMvF,GAAG6C,gBAAgB4F,UAAU1C,OAAOC,EAAQ3C,UAAW4C,EAAOC,OAA8B,IAAIC,QAAQC,SAC3GH,GAYXpD,EAAgBwD,gBAAkB,SAAyBL,EAASC,GAChE,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCvD,EAAgByD,OAAS,SAAgBC,EAAQ3H,GACvC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAG6C,gBACnF0D,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQ/C,aAAesD,EAAOL,SAC9B,MACJ,KAAK,EACDF,EAAQ1J,MAAQiK,EAAOqB,QACvB,MACJ,KAAK,EACK5B,EAAQ1C,eAAiB0C,EAAQ1C,cAAc1E,SACjDoH,EAAQ1C,cAAgB,IAC5B0C,EAAQ1C,cAAczE,KAAK0G,EAAMvF,GAAG6C,gBAAgB2F,kBAAkBlC,OAAOC,EAAQA,EAAOL,WAC5F,MACJ,KAAK,EACDF,EAAQ3C,UAAYkC,EAAMvF,GAAG6C,gBAAgB4F,UAAUnC,OAAOC,EAAQA,EAAOL,UAC7E,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXnD,EAAgBgE,gBAAkB,SAAyBN,GAGvD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCrD,EAAgBiE,OAAS,SAAgBd,GACrC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAA4B,MAAxBA,EAAQ/C,cAAwB+C,EAAQe,eAAe,kBAClD1B,EAAMyC,UAAU9B,EAAQ/C,cACzB,MAAO,iCACf,GAAqB,MAAjB+C,EAAQ1J,OAAiB0J,EAAQe,eAAe,SAChD,OAAQf,EAAQ1J,OAChB,QACI,MAAO,6BACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAGT,GAA6B,MAAzB0J,EAAQ1C,eAAyB0C,EAAQe,eAAe,iBAAkB,CAC1E,IAAK7H,MAAM8H,QAAQhB,EAAQ1C,eACvB,MAAO,gCACX,IAAK,IAAIlF,EAAI,EAAGA,EAAI4H,EAAQ1C,cAAc1E,SAAUR,EAEhD,GADI6I,EAAQ1B,EAAMvF,GAAG6C,gBAAgB2F,kBAAkB1B,OAAOd,EAAQ1C,cAAclF,IAEhF,MAAO,iBAAmB6I,EAIlC,IAAIA,EADR,OAAyB,MAArBjB,EAAQ3C,WAAqB2C,EAAQe,eAAe,eAChDE,EAAQ1B,EAAMvF,GAAG6C,gBAAgB4F,UAAU3B,OAAOd,EAAQ3C,YAEnD,aAAe4D,EAEvB,MAWXpE,EAAgBqE,WAAa,SAAoBC,GAC7C,GAAIA,aAAkB5B,EAAMvF,GAAG6C,gBAC3B,OAAOsE,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAG6C,gBAG3B,OAF2B,MAAvBsE,EAAOlE,eACP+C,EAAQ/C,aAAekE,EAAOlE,eAAiB,GAC3CkE,EAAO7K,OACf,IAAK,UACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,0BACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,2BACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,2BACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,SACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAChB,MACJ,IAAK,QACL,KAAK,EACD0J,EAAQ1J,MAAQ,EAGpB,GAAI6K,EAAO7D,cAAe,CACtB,IAAKpE,MAAM8H,QAAQG,EAAO7D,eACtB,MAAM8D,UAAU,qDACpBpB,EAAQ1C,cAAgB,GACxB,IAAK,IAAIlF,EAAI,EAAGA,EAAI+I,EAAO7D,cAAc1E,SAAUR,EAAG,CAClD,GAAuC,kBAA5B+I,EAAO7D,cAAclF,GAC5B,MAAMgJ,UAAU,sDACpBpB,EAAQ1C,cAAclF,GAAKmH,EAAMvF,GAAG6C,gBAAgB2F,kBAAkBtB,WAAWC,EAAO7D,cAAclF,KAG9G,GAAwB,MAApB+I,EAAO9D,UAAmB,CAC1B,GAAgC,kBAArB8D,EAAO9D,UACd,MAAM+D,UAAU,kDACpBpB,EAAQ3C,UAAYkC,EAAMvF,GAAG6C,gBAAgB4F,UAAUvB,WAAWC,EAAO9D,WAE7E,OAAO2C,GAYXnD,EAAgB3B,SAAW,SAAkB8E,EAASnG,GAC7CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAYb,IAXItH,EAAQwH,QAAUxH,EAAQiD,YAC1BqE,EAAO7D,cAAgB,IACvBzD,EAAQiD,WACRqE,EAAOlE,aAAe,EACtBkE,EAAO7K,MAAQuD,EAAQsB,QAAUC,OAAS,UAAY,EACtD+F,EAAO9D,UAAY,MAEK,MAAxB2C,EAAQ/C,cAAwB+C,EAAQe,eAAe,kBACvDI,EAAOlE,aAAe+C,EAAQ/C,cACb,MAAjB+C,EAAQ1J,OAAiB0J,EAAQe,eAAe,WAChDI,EAAO7K,MAAQuD,EAAQsB,QAAUC,OAASmE,EAAMvF,GAAG6C,gBAAgB1C,MAAM6F,EAAQ1J,OAAS0J,EAAQ1J,OAClG0J,EAAQ1C,eAAiB0C,EAAQ1C,cAAc1E,OAAQ,CACvDuI,EAAO7D,cAAgB,GACvB,IAAK,IAAI9E,EAAI,EAAGA,EAAIwH,EAAQ1C,cAAc1E,SAAUJ,EAChD2I,EAAO7D,cAAc9E,GAAK+G,EAAMvF,GAAG6C,gBAAgB2F,kBAAkBtH,SAAS8E,EAAQ1C,cAAc9E,GAAIqB,GAIhH,OAFyB,MAArBmG,EAAQ3C,WAAqB2C,EAAQe,eAAe,eACpDI,EAAO9D,UAAYkC,EAAMvF,GAAG6C,gBAAgB4F,UAAUvH,SAAS8E,EAAQ3C,UAAWxD,IAC/EsH,GAUXtE,EAAgB+C,UAAU0B,OAAS,WAC/B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAc1D3E,EAAgB1C,MAAS,WACrB,IAAI6H,EAAa,GAAIC,EAAStC,OAAOG,OAAOkC,GAO5C,OANAC,EAAOD,EAAW,GAAK,WAAa,EACpCC,EAAOD,EAAW,GAAK,2BAA6B,EACpDC,EAAOD,EAAW,GAAK,4BAA8B,EACrDC,EAAOD,EAAW,GAAK,4BAA8B,EACrDC,EAAOD,EAAW,GAAK,UAAY,EACnCC,EAAOD,EAAW,GAAK,SAAW,EAC3BC,EARc,GAWzBpF,EAAgB2F,kBAAqB,WAmBjC,SAASA,EAAkB/C,GACvB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA8MhD,OArMAoK,EAAkB5C,UAAUxD,aAAe,EAQ3CoG,EAAkB5C,UAAUtD,YAAc,EAQ1CkG,EAAkB5C,UAAUxG,IAAK,EAUjCoJ,EAAkB1C,OAAS,SAAgBL,GACvC,OAAO,IAAI+C,EAAkB/C,IAYjC+C,EAAkBzC,OAAS,SAAgBC,EAASC,GAShD,OARKA,IACDA,EAASd,EAAQW,UACO,MAAxBE,EAAQ5D,cAAwBuD,OAAOoB,eAAeY,KAAK3B,EAAS,iBACpEC,EAAOC,OAA8B,IAAIwC,MAAM1C,EAAQ5D,cAChC,MAAvB4D,EAAQ1D,aAAuBqD,OAAOoB,eAAeY,KAAK3B,EAAS,gBACnEC,EAAOC,OAA8B,IAAIwC,MAAM1C,EAAQ1D,aACzC,MAAd0D,EAAQ5G,IAAcuG,OAAOoB,eAAeY,KAAK3B,EAAS,OAC1DC,EAAOC,OAA8B,IAAI2B,KAAK7B,EAAQ5G,IACnD6G,GAYXuC,EAAkBnC,gBAAkB,SAAyBL,EAASC,GAClE,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCoC,EAAkBlC,OAAS,SAAgBC,EAAQ3H,GACzC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAG6C,gBAAgB2F,kBACnGjC,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQ5D,aAAemE,EAAOmC,QAC9B,MACJ,KAAK,EACD1C,EAAQ1D,YAAciE,EAAOmC,QAC7B,MACJ,KAAK,EACD1C,EAAQ5G,GAAKmH,EAAOsB,OACpB,MACJ,QACItB,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXwC,EAAkB3B,gBAAkB,SAAyBN,GAGzD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCsC,EAAkB1B,OAAS,SAAgBd,GACvC,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACiB,MAAxBA,EAAQ5D,cAAwB4D,EAAQe,eAAe,iBACnB,kBAAzBf,EAAQ5D,aACR,gCACY,MAAvB4D,EAAQ1D,aAAuB0D,EAAQe,eAAe,gBACnB,kBAAxBf,EAAQ1D,YACR,+BACG,MAAd0D,EAAQ5G,IAAc4G,EAAQe,eAAe,OACnB,mBAAff,EAAQ5G,GACR,uBACR,MAWXoJ,EAAkBtB,WAAa,SAAoBC,GAC/C,GAAIA,aAAkB5B,EAAMvF,GAAG6C,gBAAgB2F,kBAC3C,OAAOrB,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAG6C,gBAAgB2F,kBAO3C,OAN2B,MAAvBrB,EAAO/E,eACP4D,EAAQ5D,aAAeuG,OAAOxB,EAAO/E,eACf,MAAtB+E,EAAO7E,cACP0D,EAAQ1D,YAAcqG,OAAOxB,EAAO7E,cACvB,MAAb6E,EAAO/H,KACP4G,EAAQ5G,GAAK2I,QAAQZ,EAAO/H,KACzB4G,GAYXwC,EAAkBtH,SAAW,SAAkB8E,EAASnG,GAC/CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAYb,OAXItH,EAAQiD,WACRqE,EAAO/E,aAAe,EACtB+E,EAAO7E,YAAc,EACrB6E,EAAO/H,IAAK,GAEY,MAAxB4G,EAAQ5D,cAAwB4D,EAAQe,eAAe,kBACvDI,EAAO/E,aAAevC,EAAQ+I,OAASC,SAAS7C,EAAQ5D,cAAgBhB,OAAO4E,EAAQ5D,cAAgB4D,EAAQ5D,cACxF,MAAvB4D,EAAQ1D,aAAuB0D,EAAQe,eAAe,iBACtDI,EAAO7E,YAAczC,EAAQ+I,OAASC,SAAS7C,EAAQ1D,aAAelB,OAAO4E,EAAQ1D,aAAe0D,EAAQ1D,aAC9F,MAAd0D,EAAQ5G,IAAc4G,EAAQe,eAAe,QAC7CI,EAAO/H,GAAK4G,EAAQ5G,IACjB+H,GAUXqB,EAAkB5C,UAAU0B,OAAS,WACjC,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnDgB,EArO0B,GAwOrC3F,EAAgB4F,UAAa,WAmBzB,SAASA,EAAUhD,GACf,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA4QhD,OAnQAqK,EAAU7C,UAAUkD,KAAO,EAQ3BL,EAAU7C,UAAUuC,IAAM,GAQ1BM,EAAU7C,UAAUmD,SAAW,EAU/BN,EAAU3C,OAAS,SAAgBL,GAC/B,OAAO,IAAIgD,EAAUhD,IAYzBgD,EAAU1C,OAAS,SAAgBC,EAASC,GASxC,OARKA,IACDA,EAASd,EAAQW,UACD,MAAhBE,EAAQ8C,MAAgBnD,OAAOoB,eAAeY,KAAK3B,EAAS,SAC5DC,EAAOC,OAA8B,GAAG0B,MAAM5B,EAAQ8C,MACvC,MAAf9C,EAAQmC,KAAexC,OAAOoB,eAAeY,KAAK3B,EAAS,QAC3DC,EAAOC,OAA8B,IAAIkC,OAAOpC,EAAQmC,KACpC,MAApBnC,EAAQ+C,UAAoBpD,OAAOoB,eAAeY,KAAK3B,EAAS,aAChEC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQ+C,UACrD9C,GAYXwC,EAAUpC,gBAAkB,SAAyBL,EAASC,GAC1D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCqC,EAAUnC,OAAS,SAAgBC,EAAQ3H,GACjC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAG6C,gBAAgB4F,UACnGlC,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQ8C,KAAOvC,EAAOqB,QACtB,MACJ,KAAK,EACD5B,EAAQmC,IAAM5B,EAAO6B,SACrB,MACJ,KAAK,EACDpC,EAAQ+C,SAAWxC,EAAOL,SAC1B,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXyC,EAAU5B,gBAAkB,SAAyBN,GAGjD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCuC,EAAU3B,OAAS,SAAgBd,GAC/B,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAoB,MAAhBA,EAAQ8C,MAAgB9C,EAAQe,eAAe,QAC/C,OAAQf,EAAQ8C,MAChB,QACI,MAAO,4BACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAGT,OAAmB,MAAf9C,EAAQmC,KAAenC,EAAQe,eAAe,SACzC1B,EAAMgD,SAASrC,EAAQmC,KACjB,uBACS,MAApBnC,EAAQ+C,UAAoB/C,EAAQe,eAAe,cAC9C1B,EAAMyC,UAAU9B,EAAQ+C,UAClB,6BACR,MAWXN,EAAUvB,WAAa,SAAoBC,GACvC,GAAIA,aAAkB5B,EAAMvF,GAAG6C,gBAAgB4F,UAC3C,OAAOtB,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAG6C,gBAAgB4F,UAC3C,OAAQtB,EAAO2B,MACf,IAAK,UACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,OACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,6BACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,qBACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,eACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,eACL,KAAK,EACD9C,EAAQ8C,KAAO,EACf,MACJ,IAAK,mBACL,KAAK,EACD9C,EAAQ8C,KAAO,EAOnB,OAJkB,MAAd3B,EAAOgB,MACPnC,EAAQmC,IAAM/G,OAAO+F,EAAOgB,MACT,MAAnBhB,EAAO4B,WACP/C,EAAQ+C,SAAW5B,EAAO4B,WAAa,GACpC/C,GAYXyC,EAAUvH,SAAW,SAAkB8E,EAASnG,GACvCA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAYb,OAXItH,EAAQiD,WACRqE,EAAO2B,KAAOjJ,EAAQsB,QAAUC,OAAS,UAAY,EACrD+F,EAAOgB,IAAM,GACbhB,EAAO4B,SAAW,GAEF,MAAhB/C,EAAQ8C,MAAgB9C,EAAQe,eAAe,UAC/CI,EAAO2B,KAAOjJ,EAAQsB,QAAUC,OAASmE,EAAMvF,GAAG6C,gBAAgB4F,UAAUO,UAAUhD,EAAQ8C,MAAQ9C,EAAQ8C,MAC/F,MAAf9C,EAAQmC,KAAenC,EAAQe,eAAe,SAC9CI,EAAOgB,IAAMnC,EAAQmC,KACD,MAApBnC,EAAQ+C,UAAoB/C,EAAQe,eAAe,cACnDI,EAAO4B,SAAW/C,EAAQ+C,UACvB5B,GAUXsB,EAAU7C,UAAU0B,OAAS,WACzB,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAe1DiB,EAAUO,UAAa,WACnB,IAAIhB,EAAa,GAAIC,EAAStC,OAAOG,OAAOkC,GAQ5C,OAPAC,EAAOD,EAAW,GAAK,WAAa,EACpCC,EAAOD,EAAW,GAAK,QAAU,EACjCC,EAAOD,EAAW,GAAK,8BAAgC,EACvDC,EAAOD,EAAW,GAAK,sBAAwB,EAC/CC,EAAOD,EAAW,GAAK,gBAAkB,EACzCC,EAAOD,EAAW,GAAK,gBAAkB,EACzCC,EAAOD,EAAW,GAAK,oBAAsB,EACtCC,EATY,GAYhBQ,EAnSkB,GAsStB5F,EA31BW,GA81BtB7C,EAAGiJ,cAAiB,WAoBhB,SAASA,EAAcxD,GACnB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAoChD,IAAI8K,EA0PJ,OArRAD,EAAcrD,UAAUhE,eAAiB,KAQzCqH,EAAcrD,UAAUnI,IAAM,KAQ9BwL,EAAcrD,UAAUuD,IAAM,KAQ9BF,EAAcrD,UAAUpD,gBAAkB,KAW1CmD,OAAOyD,eAAeH,EAAcrD,UAAW,UAAW,CACtDyD,IAAKhE,EAAMiE,YAAYJ,EAAe,CAAC,iBAAkB,MAAO,MAAO,oBACvEK,IAAKlE,EAAMmE,YAAYN,KAW3BD,EAAcnD,OAAS,SAAgBL,GACnC,OAAO,IAAIwD,EAAcxD,IAY7BwD,EAAclD,OAAS,SAAgBC,EAASC,GAW5C,OAVKA,IACDA,EAASd,EAAQW,UACS,MAA1BE,EAAQpE,gBAA0B+D,OAAOoB,eAAeY,KAAK3B,EAAS,mBACtET,EAAMvF,GAAGC,eAAe8F,OAAOC,EAAQpE,eAAgBqE,EAAOC,OAA8B,IAAIC,QAAQC,SACzF,MAAfJ,EAAQvI,KAAekI,OAAOoB,eAAeY,KAAK3B,EAAS,QAC3DT,EAAMvF,GAAGkI,IAAInC,OAAOC,EAAQvI,IAAKwI,EAAOC,OAA8B,IAAIC,QAAQC,SACnE,MAAfJ,EAAQmD,KAAexD,OAAOoB,eAAeY,KAAK3B,EAAS,QAC3DT,EAAMvF,GAAGsI,IAAIvC,OAAOC,EAAQmD,IAAKlD,EAAOC,OAA8B,IAAIC,QAAQC,SACvD,MAA3BJ,EAAQxD,iBAA2BmD,OAAOoB,eAAeY,KAAK3B,EAAS,oBACvET,EAAMvF,GAAG6C,gBAAgBkD,OAAOC,EAAQxD,gBAAiByD,EAAOC,OAA8B,IAAIC,QAAQC,SACvGH,GAYXgD,EAAc5C,gBAAkB,SAAyBL,EAASC,GAC9D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxC6C,EAAc3C,OAAS,SAAgBC,EAAQ3H,GACrC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGiJ,cACnF1C,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQpE,eAAiB2D,EAAMvF,GAAGC,eAAeqG,OAAOC,EAAQA,EAAOL,UACvE,MACJ,KAAK,EACDF,EAAQvI,IAAM8H,EAAMvF,GAAGkI,IAAI5B,OAAOC,EAAQA,EAAOL,UACjD,MACJ,KAAK,EACDF,EAAQmD,IAAM5D,EAAMvF,GAAGsI,IAAIhC,OAAOC,EAAQA,EAAOL,UACjD,MACJ,KAAK,EACDF,EAAQxD,gBAAkB+C,EAAMvF,GAAG6C,gBAAgByD,OAAOC,EAAQA,EAAOL,UACzE,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXiD,EAAcpC,gBAAkB,SAAyBN,GAGrD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtC+C,EAAcnC,OAAS,SAAgBd,GACnC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,IAAIP,EAAa,GACjB,GAA8B,MAA1BO,EAAQpE,gBAA0BoE,EAAQe,eAAe,oBACzDtB,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAGC,eAAe6G,OAAOd,EAAQpE,iBAE/C,MAAO,kBAAoBqF,EAGvC,GAAmB,MAAfjB,EAAQvI,KAAeuI,EAAQe,eAAe,OAAQ,CACtD,GAA2B,IAAvBtB,EAAWgE,QACX,MAAO,2BAIP,GAHJhE,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAGkI,IAAIpB,OAAOd,EAAQvI,KAEpC,MAAO,OAASwJ,EAG5B,GAAmB,MAAfjB,EAAQmD,KAAenD,EAAQe,eAAe,OAAQ,CACtD,GAA2B,IAAvBtB,EAAWgE,QACX,MAAO,2BAIP,GAHJhE,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAGsI,IAAIxB,OAAOd,EAAQmD,KAEpC,MAAO,OAASlC,EAG5B,GAA+B,MAA3BjB,EAAQxD,iBAA2BwD,EAAQe,eAAe,mBAAoB,CAC9E,GAA2B,IAAvBtB,EAAWgE,QACX,MAAO,2BAGP,IAAIxC,EACJ,GAHJxB,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAG6C,gBAAgBiE,OAAOd,EAAQxD,iBAEhD,MAAO,mBAAqByE,EAGxC,OAAO,MAWXgC,EAAc/B,WAAa,SAAoBC,GAC3C,GAAIA,aAAkB5B,EAAMvF,GAAGiJ,cAC3B,OAAO9B,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGiJ,cAC3B,GAA6B,MAAzB9B,EAAOvF,eAAwB,CAC/B,GAAqC,kBAA1BuF,EAAOvF,eACd,MAAMwF,UAAU,qDACpBpB,EAAQpE,eAAiB2D,EAAMvF,GAAGC,eAAeiH,WAAWC,EAAOvF,gBAEvE,GAAkB,MAAduF,EAAO1J,IAAa,CACpB,GAA0B,kBAAf0J,EAAO1J,IACd,MAAM2J,UAAU,0CACpBpB,EAAQvI,IAAM8H,EAAMvF,GAAGkI,IAAIhB,WAAWC,EAAO1J,KAEjD,GAAkB,MAAd0J,EAAOgC,IAAa,CACpB,GAA0B,kBAAfhC,EAAOgC,IACd,MAAM/B,UAAU,0CACpBpB,EAAQmD,IAAM5D,EAAMvF,GAAGsI,IAAIpB,WAAWC,EAAOgC,KAEjD,GAA8B,MAA1BhC,EAAO3E,gBAAyB,CAChC,GAAsC,kBAA3B2E,EAAO3E,gBACd,MAAM4E,UAAU,sDACpBpB,EAAQxD,gBAAkB+C,EAAMvF,GAAG6C,gBAAgBqE,WAAWC,EAAO3E,iBAEzE,OAAOwD,GAYXiD,EAAc/H,SAAW,SAAkB8E,EAASnG,GAC3CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAqBb,OApB8B,MAA1BnB,EAAQpE,gBAA0BoE,EAAQe,eAAe,oBACzDI,EAAOvF,eAAiB2D,EAAMvF,GAAGC,eAAeiB,SAAS8E,EAAQpE,eAAgB/B,GAC7EA,EAAQ6J,SACRvC,EAAOsC,QAAU,mBAEN,MAAfzD,EAAQvI,KAAeuI,EAAQe,eAAe,SAC9CI,EAAO1J,IAAM8H,EAAMvF,GAAGkI,IAAIhH,SAAS8E,EAAQvI,IAAKoC,GAC5CA,EAAQ6J,SACRvC,EAAOsC,QAAU,QAEN,MAAfzD,EAAQmD,KAAenD,EAAQe,eAAe,SAC9CI,EAAOgC,IAAM5D,EAAMvF,GAAGsI,IAAIpH,SAAS8E,EAAQmD,IAAKtJ,GAC5CA,EAAQ6J,SACRvC,EAAOsC,QAAU,QAEM,MAA3BzD,EAAQxD,iBAA2BwD,EAAQe,eAAe,qBAC1DI,EAAO3E,gBAAkB+C,EAAMvF,GAAG6C,gBAAgB3B,SAAS8E,EAAQxD,gBAAiB3C,GAChFA,EAAQ6J,SACRvC,EAAOsC,QAAU,oBAElBtC,GAUX8B,EAAcrD,UAAU0B,OAAS,WAC7B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnDyB,EAtTS,GAyTpBjJ,EAAG2J,iBAAoB,WAiBnB,SAASA,EAAiBlE,GAEtB,GADAjJ,KAAKqF,QAAU,GACX4D,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA2ahD,OAlaAuL,EAAiB/D,UAAU/D,QAAUwD,EAAMQ,WAU3C8D,EAAiB7D,OAAS,SAAgBL,GACtC,OAAO,IAAIkE,EAAiBlE,IAYhCkE,EAAiB5D,OAAS,SAAgBC,EAASC,GAG/C,GAFKA,IACDA,EAASd,EAAQW,UACE,MAAnBE,EAAQnE,SAAmBmE,EAAQnE,QAAQjD,OAC3C,IAAK,IAAIR,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAC1CmH,EAAMvF,GAAG2J,iBAAiBC,cAAc7D,OAAOC,EAAQnE,QAAQzD,GAAI6H,EAAOC,OAA8B,IAAIC,QAAQC,SAC5H,OAAOH,GAYX0D,EAAiBtD,gBAAkB,SAAyBL,EAASC,GACjE,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCuD,EAAiBrD,OAAS,SAAgBC,EAAQ3H,GACxC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAG2J,iBACnFpD,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACKX,EAAQnE,SAAWmE,EAAQnE,QAAQjD,SACrCoH,EAAQnE,QAAU,IACtBmE,EAAQnE,QAAQhD,KAAK0G,EAAMvF,GAAG2J,iBAAiBC,cAActD,OAAOC,EAAQA,EAAOL,WACnF,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaX2D,EAAiB9C,gBAAkB,SAAyBN,GAGxD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCyD,EAAiB7C,OAAS,SAAgBd,GACtC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAuB,MAAnBA,EAAQnE,SAAmBmE,EAAQe,eAAe,WAAY,CAC9D,IAAK7H,MAAM8H,QAAQhB,EAAQnE,SACvB,MAAO,0BACX,IAAK,IAAIzD,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAAG,CAC7C,IAAI6I,EAAQ1B,EAAMvF,GAAG2J,iBAAiBC,cAAc9C,OAAOd,EAAQnE,QAAQzD,IAC3E,GAAI6I,EACA,MAAO,WAAaA,GAGhC,OAAO,MAWX0C,EAAiBzC,WAAa,SAAoBC,GAC9C,GAAIA,aAAkB5B,EAAMvF,GAAG2J,iBAC3B,OAAOxC,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAG2J,iBAC3B,GAAIxC,EAAOtF,QAAS,CAChB,IAAK3C,MAAM8H,QAAQG,EAAOtF,SACtB,MAAMuF,UAAU,gDACpBpB,EAAQnE,QAAU,GAClB,IAAK,IAAIzD,EAAI,EAAGA,EAAI+I,EAAOtF,QAAQjD,SAAUR,EAAG,CAC5C,GAAiC,kBAAtB+I,EAAOtF,QAAQzD,GACtB,MAAMgJ,UAAU,iDACpBpB,EAAQnE,QAAQzD,GAAKmH,EAAMvF,GAAG2J,iBAAiBC,cAAc1C,WAAWC,EAAOtF,QAAQzD,KAG/F,OAAO4H,GAYX2D,EAAiBzI,SAAW,SAAkB8E,EAASnG,GAC9CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAGb,IAFItH,EAAQwH,QAAUxH,EAAQiD,YAC1BqE,EAAOtF,QAAU,IACjBmE,EAAQnE,SAAWmE,EAAQnE,QAAQjD,OAAQ,CAC3CuI,EAAOtF,QAAU,GACjB,IAAK,IAAIrD,EAAI,EAAGA,EAAIwH,EAAQnE,QAAQjD,SAAUJ,EAC1C2I,EAAOtF,QAAQrD,GAAK+G,EAAMvF,GAAG2J,iBAAiBC,cAAc1I,SAAS8E,EAAQnE,QAAQrD,GAAIqB,GAEjG,OAAOsH,GAUXwC,EAAiB/D,UAAU0B,OAAS,WAChC,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAG1DmC,EAAiBC,cAAiB,WAkB9B,SAASA,EAAcnE,GACnB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA2NhD,OAlNAwL,EAAchE,UAAUiE,OAAS,EAQjCD,EAAchE,UAAUkE,MAAQ,EAUhCF,EAAc9D,OAAS,SAAgBL,GACnC,OAAO,IAAImE,EAAcnE,IAY7BmE,EAAc7D,OAAS,SAAgBC,EAASC,GAO5C,OANKA,IACDA,EAASd,EAAQW,UACC,MAAlBE,EAAQ6D,QAAkBlE,OAAOoB,eAAeY,KAAK3B,EAAS,WAC9DC,EAAOC,OAA8B,GAAG0B,MAAM5B,EAAQ6D,QACrC,MAAjB7D,EAAQ8D,OAAiBnE,OAAOoB,eAAeY,KAAK3B,EAAS,UAC7DC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQ8D,OACrD7D,GAYX2D,EAAcvD,gBAAkB,SAAyBL,EAASC,GAC9D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCwD,EAActD,OAAS,SAAgBC,EAAQ3H,GACrC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAG2J,iBAAiBC,cACpGrD,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQ6D,OAAStD,EAAOqB,QACxB,MACJ,KAAK,EACD5B,EAAQ8D,MAAQvD,EAAOL,SACvB,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaX4D,EAAc/C,gBAAkB,SAAyBN,GAGrD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtC0D,EAAc9C,OAAS,SAAgBd,GACnC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAsB,MAAlBA,EAAQ6D,QAAkB7D,EAAQe,eAAe,UACjD,OAAQf,EAAQ6D,QAChB,QACI,MAAO,8BACX,KAAK,EACL,KAAK,EACL,KAAK,GAGT,OAAqB,MAAjB7D,EAAQ8D,OAAiB9D,EAAQe,eAAe,WAC3C1B,EAAMyC,UAAU9B,EAAQ8D,OAClB,0BACR,MAWXF,EAAc1C,WAAa,SAAoBC,GAC3C,GAAIA,aAAkB5B,EAAMvF,GAAG2J,iBAAiBC,cAC5C,OAAOzC,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAG2J,iBAAiBC,cAC5C,OAAQzC,EAAO0C,QACf,IAAK,QACL,KAAK,EACD7D,EAAQ6D,OAAS,EACjB,MACJ,IAAK,aACL,KAAK,EACD7D,EAAQ6D,OAAS,EACjB,MACJ,IAAK,iBACL,KAAK,EACD7D,EAAQ6D,OAAS,EAKrB,OAFoB,MAAhB1C,EAAO2C,QACP9D,EAAQ8D,MAAQ3C,EAAO2C,QAAU,GAC9B9D,GAYX4D,EAAc1I,SAAW,SAAkB8E,EAASnG,GAC3CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GASb,OARItH,EAAQiD,WACRqE,EAAO0C,OAAShK,EAAQsB,QAAUC,OAAS,QAAU,EACrD+F,EAAO2C,MAAQ,GAEG,MAAlB9D,EAAQ6D,QAAkB7D,EAAQe,eAAe,YACjDI,EAAO0C,OAAShK,EAAQsB,QAAUC,OAASmE,EAAMvF,GAAG2J,iBAAiBC,cAAcG,OAAO/D,EAAQ6D,QAAU7D,EAAQ6D,QACnG,MAAjB7D,EAAQ8D,OAAiB9D,EAAQe,eAAe,WAChDI,EAAO2C,MAAQ9D,EAAQ8D,OACpB3C,GAUXyC,EAAchE,UAAU0B,OAAS,WAC7B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAW1DoC,EAAcG,OAAU,WACpB,IAAI/B,EAAa,GAAIC,EAAStC,OAAOG,OAAOkC,GAI5C,OAHAC,EAAOD,EAAW,GAAK,SAAW,EAClCC,EAAOD,EAAW,GAAK,cAAgB,EACvCC,EAAOD,EAAW,GAAK,kBAAoB,EACpCC,EALa,GAQjB2B,EAjPuB,GAoP3BD,EAjcY,GAocvB3J,EAAGgK,gBAAmB,WAiBlB,SAASA,EAAgBvE,GAErB,GADAjJ,KAAKqF,QAAU,GACX4D,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA+ahD,OAtaA4L,EAAgBpE,UAAU/D,QAAUwD,EAAMQ,WAU1CmE,EAAgBlE,OAAS,SAAgBL,GACrC,OAAO,IAAIuE,EAAgBvE,IAY/BuE,EAAgBjE,OAAS,SAAgBC,EAASC,GAG9C,GAFKA,IACDA,EAASd,EAAQW,UACE,MAAnBE,EAAQnE,SAAmBmE,EAAQnE,QAAQjD,OAC3C,IAAK,IAAIR,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAC1CmH,EAAMvF,GAAGgK,gBAAgBC,aAAalE,OAAOC,EAAQnE,QAAQzD,GAAI6H,EAAOC,OAA8B,IAAIC,QAAQC,SAC1H,OAAOH,GAYX+D,EAAgB3D,gBAAkB,SAAyBL,EAASC,GAChE,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxC4D,EAAgB1D,OAAS,SAAgBC,EAAQ3H,GACvC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGgK,gBACnFzD,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACKX,EAAQnE,SAAWmE,EAAQnE,QAAQjD,SACrCoH,EAAQnE,QAAU,IACtBmE,EAAQnE,QAAQhD,KAAK0G,EAAMvF,GAAGgK,gBAAgBC,aAAa3D,OAAOC,EAAQA,EAAOL,WACjF,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXgE,EAAgBnD,gBAAkB,SAAyBN,GAGvD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtC8D,EAAgBlD,OAAS,SAAgBd,GACrC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,GAAuB,MAAnBA,EAAQnE,SAAmBmE,EAAQe,eAAe,WAAY,CAC9D,IAAK7H,MAAM8H,QAAQhB,EAAQnE,SACvB,MAAO,0BACX,IAAK,IAAIzD,EAAI,EAAGA,EAAI4H,EAAQnE,QAAQjD,SAAUR,EAAG,CAC7C,IAAI6I,EAAQ1B,EAAMvF,GAAGgK,gBAAgBC,aAAanD,OAAOd,EAAQnE,QAAQzD,IACzE,GAAI6I,EACA,MAAO,WAAaA,GAGhC,OAAO,MAWX+C,EAAgB9C,WAAa,SAAoBC,GAC7C,GAAIA,aAAkB5B,EAAMvF,GAAGgK,gBAC3B,OAAO7C,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGgK,gBAC3B,GAAI7C,EAAOtF,QAAS,CAChB,IAAK3C,MAAM8H,QAAQG,EAAOtF,SACtB,MAAMuF,UAAU,+CACpBpB,EAAQnE,QAAU,GAClB,IAAK,IAAIzD,EAAI,EAAGA,EAAI+I,EAAOtF,QAAQjD,SAAUR,EAAG,CAC5C,GAAiC,kBAAtB+I,EAAOtF,QAAQzD,GACtB,MAAMgJ,UAAU,gDACpBpB,EAAQnE,QAAQzD,GAAKmH,EAAMvF,GAAGgK,gBAAgBC,aAAa/C,WAAWC,EAAOtF,QAAQzD,KAG7F,OAAO4H,GAYXgE,EAAgB9I,SAAW,SAAkB8E,EAASnG,GAC7CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAGb,IAFItH,EAAQwH,QAAUxH,EAAQiD,YAC1BqE,EAAOtF,QAAU,IACjBmE,EAAQnE,SAAWmE,EAAQnE,QAAQjD,OAAQ,CAC3CuI,EAAOtF,QAAU,GACjB,IAAK,IAAIrD,EAAI,EAAGA,EAAIwH,EAAQnE,QAAQjD,SAAUJ,EAC1C2I,EAAOtF,QAAQrD,GAAK+G,EAAMvF,GAAGgK,gBAAgBC,aAAa/I,SAAS8E,EAAQnE,QAAQrD,GAAIqB,GAE/F,OAAOsH,GAUX6C,EAAgBpE,UAAU0B,OAAS,WAC/B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAG1DwC,EAAgBC,aAAgB,WA2B5B,SAASA,EAAaxE,GAClB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KAsNhD,OA7MA6L,EAAarE,UAAUsE,gBAAkB,EAYzCD,EAAarE,UAAUuE,cAAgB,EAYvCF,EAAarE,UAAUwE,WAAa,EAUpCH,EAAanE,OAAS,SAAgBL,GAClC,OAAO,IAAIwE,EAAaxE,IAY5BwE,EAAalE,OAAS,SAAgBC,EAASC,GAS3C,OARKA,IACDA,EAASd,EAAQW,UACU,MAA3BE,EAAQkE,iBAA2BvE,OAAOoB,eAAeY,KAAK3B,EAAS,oBACvEC,EAAOC,OAA8B,GAAGA,OAAOF,EAAQkE,iBAC9B,MAAzBlE,EAAQmE,eAAyBxE,OAAOoB,eAAeY,KAAK3B,EAAS,kBACrEC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQmE,eAClC,MAAtBnE,EAAQoE,YAAsBzE,OAAOoB,eAAeY,KAAK3B,EAAS,eAClEC,EAAOC,OAA8B,IAAIA,OAAOF,EAAQoE,YACrDnE,GAYXgE,EAAa5D,gBAAkB,SAAyBL,EAASC,GAC7D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxC6D,EAAa3D,OAAS,SAAgBC,EAAQ3H,GACpC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGgK,gBAAgBC,aACnG1D,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQkE,gBAAkB3D,EAAOL,SACjC,MACJ,KAAK,EACDF,EAAQmE,cAAgB5D,EAAOL,SAC/B,MACJ,KAAK,EACDF,EAAQoE,WAAa7D,EAAOL,SAC5B,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXiE,EAAapD,gBAAkB,SAAyBN,GAGpD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtC+D,EAAanD,OAAS,SAAgBd,GAClC,MAAuB,kBAAZA,GAAoC,OAAZA,EACxB,kBACoB,MAA3BA,EAAQkE,iBAA2BlE,EAAQe,eAAe,qBACrD1B,EAAMyC,UAAU9B,EAAQkE,iBAClB,oCACc,MAAzBlE,EAAQmE,eAAyBnE,EAAQe,eAAe,mBACnD1B,EAAMyC,UAAU9B,EAAQmE,eAClB,kCACW,MAAtBnE,EAAQoE,YAAsBpE,EAAQe,eAAe,gBAChD1B,EAAMyC,UAAU9B,EAAQoE,YAClB,+BACR,MAWXH,EAAa/C,WAAa,SAAoBC,GAC1C,GAAIA,aAAkB5B,EAAMvF,GAAGgK,gBAAgBC,aAC3C,OAAO9C,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGgK,gBAAgBC,aAO3C,OAN8B,MAA1B9C,EAAO+C,kBACPlE,EAAQkE,gBAAkB/C,EAAO+C,kBAAoB,GAC7B,MAAxB/C,EAAOgD,gBACPnE,EAAQmE,cAAgBhD,EAAOgD,gBAAkB,GAC5B,MAArBhD,EAAOiD,aACPpE,EAAQoE,WAAajD,EAAOiD,aAAe,GACxCpE,GAYXiE,EAAa/I,SAAW,SAAkB8E,EAASnG,GAC1CA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAYb,OAXItH,EAAQiD,WACRqE,EAAO+C,gBAAkB,EACzB/C,EAAOgD,cAAgB,EACvBhD,EAAOiD,WAAa,GAEO,MAA3BpE,EAAQkE,iBAA2BlE,EAAQe,eAAe,qBAC1DI,EAAO+C,gBAAkBlE,EAAQkE,iBACR,MAAzBlE,EAAQmE,eAAyBnE,EAAQe,eAAe,mBACxDI,EAAOgD,cAAgBnE,EAAQmE,eACT,MAAtBnE,EAAQoE,YAAsBpE,EAAQe,eAAe,gBACrDI,EAAOiD,WAAapE,EAAQoE,YACzBjD,GAUX8C,EAAarE,UAAU0B,OAAS,WAC5B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnDyC,EArPqB,GAwPzBD,EArcW,GAwctBhK,EAAGqK,YAAe,WAmBd,SAASA,EAAY5E,GACjB,GAAIA,EACA,IAAK,IAAIC,EAAOC,OAAOD,KAAKD,GAAarH,EAAI,EAAGA,EAAIsH,EAAK9G,SAAUR,EACpC,MAAvBqH,EAAWC,EAAKtH,MAChB5B,KAAKkJ,EAAKtH,IAAMqH,EAAWC,EAAKtH,KA4BhD,IAAI8K,EAsNJ,OAzOAmB,EAAYzE,UAAU2C,MAAQ,EAQ9B8B,EAAYzE,UAAU0E,iBAAmB,KAQzCD,EAAYzE,UAAU2E,gBAAkB,KAWxC5E,OAAOyD,eAAeiB,EAAYzE,UAAW,UAAW,CACpDyD,IAAKhE,EAAMiE,YAAYJ,EAAe,CAAC,mBAAoB,oBAC3DK,IAAKlE,EAAMmE,YAAYN,KAW3BmB,EAAYvE,OAAS,SAAgBL,GACjC,OAAO,IAAI4E,EAAY5E,IAY3B4E,EAAYtE,OAAS,SAAgBC,EAASC,GAS1C,OARKA,IACDA,EAASd,EAAQW,UACA,MAAjBE,EAAQuC,OAAiB5C,OAAOoB,eAAeY,KAAK3B,EAAS,UAC7DC,EAAOC,OAA8B,GAAGA,OAAOF,EAAQuC,OAC3B,MAA5BvC,EAAQsE,kBAA4B3E,OAAOoB,eAAeY,KAAK3B,EAAS,qBACxET,EAAMvF,GAAG2J,iBAAiB5D,OAAOC,EAAQsE,iBAAkBrE,EAAOC,OAA8B,IAAIC,QAAQC,SACjF,MAA3BJ,EAAQuE,iBAA2B5E,OAAOoB,eAAeY,KAAK3B,EAAS,oBACvET,EAAMvF,GAAGgK,gBAAgBjE,OAAOC,EAAQuE,gBAAiBtE,EAAOC,OAA8B,IAAIC,QAAQC,SACvGH,GAYXoE,EAAYhE,gBAAkB,SAAyBL,EAASC,GAC5D,OAAOzJ,KAAKuJ,OAAOC,EAASC,GAAQG,UAcxCiE,EAAY/D,OAAS,SAAgBC,EAAQ3H,GACnC2H,aAAkBtB,IACpBsB,EAAStB,EAAQa,OAAOS,IAE5B,IADA,IAAIC,OAAiB5F,IAAXhC,EAAuB2H,EAAOE,IAAMF,EAAOG,IAAM9H,EAAQoH,EAAU,IAAIT,EAAMvF,GAAGqK,YACnF9D,EAAOG,IAAMF,GAAK,CACrB,IAAIG,EAAMJ,EAAOL,SACjB,OAAQS,IAAQ,GAChB,KAAK,EACDX,EAAQuC,MAAQhC,EAAOL,SACvB,MACJ,KAAK,EACDF,EAAQsE,iBAAmB/E,EAAMvF,GAAG2J,iBAAiBrD,OAAOC,EAAQA,EAAOL,UAC3E,MACJ,KAAK,EACDF,EAAQuE,gBAAkBhF,EAAMvF,GAAGgK,gBAAgB1D,OAAOC,EAAQA,EAAOL,UACzE,MACJ,QACIK,EAAOK,SAAe,EAAND,IAIxB,OAAOX,GAaXqE,EAAYxD,gBAAkB,SAAyBN,GAGnD,OAFMA,aAAkBtB,IACpBsB,EAAS,IAAItB,EAAQsB,IAClB/J,KAAK8J,OAAOC,EAAQA,EAAOL,WAWtCmE,EAAYvD,OAAS,SAAgBd,GACjC,GAAuB,kBAAZA,GAAoC,OAAZA,EAC/B,MAAO,kBACX,IAAIP,EAAa,GACjB,GAAqB,MAAjBO,EAAQuC,OAAiBvC,EAAQe,eAAe,WAC3C1B,EAAMyC,UAAU9B,EAAQuC,OACzB,MAAO,0BACf,GAAgC,MAA5BvC,EAAQsE,kBAA4BtE,EAAQe,eAAe,sBAC3DtB,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAG2J,iBAAiB7C,OAAOd,EAAQsE,mBAEjD,MAAO,oBAAsBrD,EAGzC,GAA+B,MAA3BjB,EAAQuE,iBAA2BvE,EAAQe,eAAe,mBAAoB,CAC9E,GAA2B,IAAvBtB,EAAWgE,QACX,MAAO,2BAGP,IAAIxC,EACJ,GAHJxB,EAAWgE,QAAU,EAEbxC,EAAQ1B,EAAMvF,GAAGgK,gBAAgBlD,OAAOd,EAAQuE,iBAEhD,MAAO,mBAAqBtD,EAGxC,OAAO,MAWXoD,EAAYnD,WAAa,SAAoBC,GACzC,GAAIA,aAAkB5B,EAAMvF,GAAGqK,YAC3B,OAAOlD,EACX,IAAInB,EAAU,IAAIT,EAAMvF,GAAGqK,YAG3B,GAFoB,MAAhBlD,EAAOoB,QACPvC,EAAQuC,MAAQpB,EAAOoB,QAAU,GACN,MAA3BpB,EAAOmD,iBAA0B,CACjC,GAAuC,kBAA5BnD,EAAOmD,iBACd,MAAMlD,UAAU,qDACpBpB,EAAQsE,iBAAmB/E,EAAMvF,GAAG2J,iBAAiBzC,WAAWC,EAAOmD,kBAE3E,GAA8B,MAA1BnD,EAAOoD,gBAAyB,CAChC,GAAsC,kBAA3BpD,EAAOoD,gBACd,MAAMnD,UAAU,oDACpBpB,EAAQuE,gBAAkBhF,EAAMvF,GAAGgK,gBAAgB9C,WAAWC,EAAOoD,iBAEzE,OAAOvE,GAYXqE,EAAYnJ,SAAW,SAAkB8E,EAASnG,GACzCA,IACDA,EAAU,IACd,IAAIsH,EAAS,GAeb,OAdItH,EAAQiD,WACRqE,EAAOoB,MAAQ,GACE,MAAjBvC,EAAQuC,OAAiBvC,EAAQe,eAAe,WAChDI,EAAOoB,MAAQvC,EAAQuC,OACK,MAA5BvC,EAAQsE,kBAA4BtE,EAAQe,eAAe,sBAC3DI,EAAOmD,iBAAmB/E,EAAMvF,GAAG2J,iBAAiBzI,SAAS8E,EAAQsE,iBAAkBzK,GACnFA,EAAQ6J,SACRvC,EAAOsC,QAAU,qBAEM,MAA3BzD,EAAQuE,iBAA2BvE,EAAQe,eAAe,qBAC1DI,EAAOoD,gBAAkBhF,EAAMvF,GAAGgK,gBAAgB9I,SAAS8E,EAAQuE,gBAAiB1K,GAChFA,EAAQ6J,SACRvC,EAAOsC,QAAU,oBAElBtC,GAUXkD,EAAYzE,UAAU0B,OAAS,WAC3B,OAAO9K,KAAK+K,YAAYrG,SAAS1E,KAAMwI,EAAUM,KAAKkC,gBAGnD6C,EAzQO,GA4QXrK,EAxtGC,GA2tGLuF,IAzuGG,gC","file":"static/js/main.f505373f.chunk.js","sourcesContent":["import React from 'react';\nimport './style.css';\n\nfunction Header() {\n  return (\n    <div className=\"header\">\n      CODE ART: I/O\n    </div>\n  );\n}\n\nexport default Header;\n","import React, { Component } from \"react\";\nimport './style.css';\n\nclass InputBoardButton extends Component {\n    constructor() {\n        super();\n        this.state = {\n            buttonOn: false\n        };\n    }\n\n    render() {\n\n        return (\n            <div \n                className={`input-board-button-${this.props.color}`}\n                // onClick={()=>{\n                //     this.props.socket.emit('button pressed', this.props.buttonID)                    \n                // }}\n                \n            >\n\n                {this.props.buttonValue}\n\n            </div> \n        )\n    }\n}\nexport default InputBoardButton;\n\n\n","export const apiURL = 'http://10.0.0.11:8090'","import React, { Component } from \"react\";\nimport './style.css';\nimport InputBoardButton from '../InputBoardButton';\nimport Select from 'react-select';\nimport {apiURL} from '../../constants';\n\n// import { TiTimesOutline, TiTimes, TiStarOutline, TiStar,  TiMediaStopOutline, TiMediaStop, TiMediaRecord, TiMediaRecordOutline } from \"react-icons/ti\";\n\nconst boxLayouts = [\n    {position: 0, symbol: '$', color: 'yellow'},  // 0\n    {position: 0, symbol: '*', color: 'pink'},    // 1\n\n    {position: 1, symbol: '%', color: 'yellow'},  // 2\n    {position: 1, symbol: '!', color: 'orange'},  // 3\n\n    {position: 2, symbol: '@', color: 'pink'},    // 4\n    {position: 2, symbol: '&', color: 'green'},   // 5\n\n    {position: 3, symbol: '#', color: 'pink'},    // 6\n    {position: 3, symbol: '?', color: 'yellow'},  // 7\n\n    {position: 4, symbol: '$', color: 'orange'},  // 8\n    {position: 4, symbol: '*', color: 'pink'},    // 9\n\n    {position: 5, symbol: '%', color: 'orange'},  // 10\n    {position: 5, symbol: '!', color: 'orange'},  // 11\n\n    {position: 6, symbol: '@', color: 'green'},   // 12\n    {position: 6, symbol: '&', color: 'green'},   // 13\n\n    {position: 7, symbol: '#', color: 'green'},   // 14\n    {position: 7, symbol: '?', color: 'yellow'},  // 15\n\n    {position: 8, symbol: '#', color: 'yellow'},  // 16\n    {position: 8, symbol: '?', color: 'yellow'},  // 17\n\n    {position: 9, symbol: '$', color: 'yellow'},  // 18\n    {position: 9, symbol: '*', color: 'green'},   // 19\n\n    {position: 10, symbol: '%', color: 'pink'},   // 20\n    {position: 10, symbol: '!', color: 'orange'}, // 21\n\n    {position: 11, symbol: '@', color: 'pink'},   // 22\n    {position: 11, symbol: '&', color: 'pink'},   // 23\n\n    {position: 12, symbol: '#', color: 'orange'}, // 24\n    {position: 12, symbol: '?', color: 'yellow'}, // 25\n\n    {position: 13, symbol: '$', color: 'orange'}, // 26\n    {position: 13, symbol: '*', color: 'green'},  // 27\n\n    {position: 14, symbol: '%', color: 'green'},  // 28\n    {position: 14, symbol: '!', color: 'orange'}, // 29\n\n    {position: 15, symbol: '@', color: 'green'},  // 30\n    {position: 15, symbol: '&', color: 'pink'},   // 31\n\n    {position: 16, symbol: '@', color: 'yellow'}, // 32\n    {position: 16, symbol: '&', color: 'pink'},   // 33\n\n    {position: 17, symbol: '#', color: 'yellow'}, // 34\n    {position: 17, symbol: '?', color: 'orange'}, // 35\n    \n    {position: 18, symbol: '*', color: 'green'},  // 36\n    {position: 18, symbol: '$', color: 'pink'},   // 37\n\n    {position: 19, symbol: '!', color: 'yellow'}, // 38\n    {position: 19, symbol: '%', color: 'pink'},   // 39\n   \n    {position: 20, symbol: '@', color: 'orange'}, // 40\n    {position: 20, symbol: '&', color: 'pink'},   // 41\n\n    {position: 21, symbol: '?', color: 'orange'}, // 41\n    {position: 21, symbol: '#', color: 'orange'}, // 42\n    \n    {position: 22, symbol: '$', color: 'green'},  // 43\n    {position: 22, symbol: '*', color: 'green'},  // 44\n\n    {position: 23, symbol: '!', color: 'yellow'}, // 45\n    {position: 23, symbol: '%', color: 'green'},  // 46\n    \n\n]\n\nconst gameDropDownList = [\n  { value: '0', label: '[ FOUR STRIPES ] The first bud of spring sings the other seeds into joining her uprising' },\n  { value: '1', label: '[ & ] technology is a useful servant but a dangerous master' },\n  { value: '2', label: '[ ! ] the future is here its just not widely distributed yet' },\n  { value: '3', label: '[ $ ] if you can control the meaning of words you can control the people who must use them' },\n  { value: '4', label: '[ GREEN ] when you want to know how things really work study them when theyre coming apart' },\n  { value: '5', label: '[ @ ] through the machineries of greed pettiness and abuse of power love occurs' },\n  { value: '6', label: '[ * ] the norms and notions of what just is isnt always justice' },\n  { value: '7', label: '[ % ] language is to the mind more than light is to the eye' },\n  { value: '8', label: '[ ? ] you can tune a guitar but you cant tuna fish unless of course you play bass' },\n  { value: '9', label: '[ ORANGE ] of all the sad words of tongue or pen the saddest are these it might have been' },\n];\n \n\n\nclass InputBoard extends Component {\n    constructor() {\n        super();\n        this.state = {\n            numberOfUsers: 0,\n            boardSymbols: Array(24).fill('X'),\n            boardColors: Array(24).fill('black'),\n            selectedOption: null\n        };\n    }\n\n\n    handleDropDown= (selectedOption) => {\n      this.setState({ selectedOption });\n      console.log(`Option selected:`, selectedOption.value);\n      fetch(`${apiURL}/game`, {\n     \n        // Adding method type\n        method: \"POST\",\n        // Adding body or contents to send\n        body: JSON.stringify({\n            game: selectedOption.value,\n        }),\n        // Adding headers to the request\n        headers: {\n            \"Content-type\": \"application/json; charset=UTF-8\"\n        }\n    }).then((response) => console.log(response))\n    };\n\n    componentDidMount() {\n        this.props.socket.on('connected users', (data) => {\n            this.setState({ numberOfUsers: data.numberOfUsers })\n        })\n\n        this.props.socket.on('button down', (data) => {\n            console.log('socket data', data)\n            this.updateInputBoardLayout(data.buttons);\n        })\n\n        this.props.socket.on('button up', (data) => {\n            this.updateInputBoardLayout(data.buttons);\n        })\n    }\n\n\n    updateInputBoardLayout = i => { // i = pin number\n        this.setState(state => {\n        //const value has to be the same as state value setState (key:value)\n          const boardSymbols= state.boardSymbols.map((item, j) => {\n            \n            if (i != null && j === boxLayouts[i].position && item !== boxLayouts[i].symbol) {\n              return boxLayouts[i].symbol;\n            } \n            else if(i != null && j === boxLayouts[i].position  && item === boxLayouts[i].symbol) {\n              return 'X';\n            } \n            \n            else{\n                return item;\n            }\n          });\n\n          const boardColors = state.boardColors.map((item, j) => {\n           \n            if (i != null && j === boxLayouts[i].position && item !== boxLayouts[i].color) {\n              return boxLayouts[i].color;\n            } \n            else if(i != null && j === boxLayouts[i].position  && item === boxLayouts[i].color) {\n              return 'black';\n            }\n            \n            else{\n                return item;\n            }\n          });\n\n          return {\n            boardSymbols,\n            boardColors\n          };\n        });\n      };\n\n    createInputGrid = () => {\n        let table = [];\n\n        for (let i = 0; i < this.state.boardSymbols.length; i++) {\n            table.push(\n                <InputBoardButton\n                    key={i}\n                    buttonID={i}\n                    buttonValue={this.state.boardSymbols[i]}\n                    socket={this.props.socket}\n                    color={this.state.boardColors[i]}\n                />\n            )\n        }\n        return table\n    }\n    \n    render() {\n      const { selectedOption } = this.state;\n\n      const customStyles = {\n        menu: (provided, state) => ({\n          ...provided,\n          // backgroundColor: 'red',\n          zIndex: 999\n        }),\n      }\n\n\n\n        return (\n            <div className=\"input-board-container\">\n                <div className=\"input-board-users\">\n                  People Playing: {this.state.numberOfUsers}\n                </div>\n                <div className=\"input-board-game-select\">\n                  <Select\n                    styles={customStyles}\n                    value={selectedOption}\n                    onChange={this.handleDropDown}\n                    options={gameDropDownList}\n                    placeholder={'Select a Game'}\n                  />\n                </div>\n                <div className=\"input-board\">\n                    {this.createInputGrid()}\n                </div>\n            </div>\n        )\n    }\n}\nexport default InputBoard;\n\n\n","import React, { Component } from \"react\";\nimport './style.css';\n\nimport {PB} from 'splitflapjs-proto'\n\n// TODO: refactor to use protobuf constants once proto generated source is separate of splitflap (& its serialport dependency that doesn't work in browser)\nconst SPLITFLAP_ERROR_STATES = [\n    PB.SplitflapState.ModuleState.State.SENSOR_ERROR,\n    PB.SplitflapState.ModuleState.State.PANIC,\n    PB.SplitflapState.ModuleState.State.STATE_DISABLED,\n]\n\nconst flapLayouts = [\n    {symbol: '_', color: 'black-empty'},\n    {symbol: 'J', color: 'black'},\n    {symbol: 'B', color: 'black'},\n    {symbol: 'M', color: 'black'},\n    {symbol: 'R', color: 'black'},\n    {symbol: '$', color: 'black'},\n    {symbol: 'V', color: 'black'},\n    {symbol: 'K', color: 'black'},\n    {symbol: 'A', color: 'black'},\n    {symbol: 'E', color: 'black'},\n    {symbol: 'N', color: 'black'},\n    {symbol: 'O', color: 'black'},\n    {symbol: '_', color: 'yellow'},\n    {symbol: '*', color: 'black'},\n    {symbol: '_', color: 'green'},\n    {symbol: 'G', color: 'black'},\n    {symbol: 'I', color: 'black'},\n    {symbol: '%', color: 'black'},\n    {symbol: 'D', color: 'black'},\n    {symbol: 'L', color: 'black'},\n    {symbol: '&', color: 'black'},\n    {symbol: '@', color: 'black'},\n    {symbol: 'C', color: 'black'},\n    {symbol: 'W', color: 'black'},\n    {symbol: 'H', color: 'black'},\n    {symbol: 'Y', color: 'black'},\n    {symbol: '_', color: 'white'},\n    {symbol: 'Q', color: 'black'},\n    {symbol: '_', color: 'pink'},\n    {symbol: '_', color: 'orange'},\n    {symbol: '!', color: 'black'},\n    {symbol: 'T', color: 'black'},\n    {symbol: 'Z', color: 'black'},\n    {symbol: 'P', color: 'black'},\n    {symbol: 'F', color: 'black'},\n    {symbol: '?', color: 'black'},\n    {symbol: 'S', color: 'black'},\n    {symbol: '#', color: 'black'},\n    {symbol: 'U', color: 'black'},\n    {symbol: 'X', color: 'black'},\n]\n\n\nclass OutputBoardFlap extends Component {\n    render() {\n        const data = this.props.data\n        let text = ''\n        const classes = ['split-flap-button']\n        let tooltip = []\n\n        if (data !== undefined) {\n            text = flapLayouts[data.flapIndex].symbol\n            classes.push(`split-flap-button-${flapLayouts[data.flapIndex].color}`)\n\n\n            const warning = (data.countMissedHome !== undefined && data.countMissedHome > 0)\n                || (data.countUnexpectedHome !== undefined && data.countUnexpectedHome > 0)\n                || (data.state !== undefined && data.state === PB.SplitflapState.ModuleState.State.LOOK_FOR_HOME)\n            if (warning) {\n                classes.push('split-flap-warning')\n            }\n\n            const error = data.state !== undefined && SPLITFLAP_ERROR_STATES.indexOf(data.state) !== -1\n            if (error) {\n                classes.push('split-flap-error')\n            }\n\n            if (data.state !== undefined) {\n                tooltip.push(`State: ${PB.SplitflapState.ModuleState.toObject(data, {enums: String}).state}`)\n            }\n            if (data.countMissedHome !== undefined) {\n                tooltip.push(`Missed home: ${data.countMissedHome}`)\n            }\n            if (data.countUnexpectedHome !== undefined) {\n                tooltip.push(`Unexpected home: ${data.countUnexpectedHome}`)\n            }\n            tooltip.push('(Click to reset)')\n        }\n\n        return (\n            <td\n                className={classes.join(' ')}\n                title={tooltip.join('\\r\\n')}\n                onClick={this.props.onResetModule}\n            >\n                {text}\n            </td> \n        )\n    }\n}\nexport default OutputBoardFlap;","import React, { Component } from \"react\";\nimport './style.css';\nimport OutputBoardFlap from '../OutputBoardFlap';\n\nclass OutputBoard extends Component {\n    createOutputGrid = () => {\n        let rows = []\n\n        let i = 0\n        while (i < this.props.splitflapState.modules.length) {\n            rows.push(this.props.splitflapState.modules.slice(i, i += 18))\n        }\n\n        return rows.map((row, y) => (\n            <tr key={y}>\n                {\n                    row.map((item, x) => {\n                        let p = {}\n                        if (this.props.onResetModule) {\n                            p['onResetModule'] = () => { this.props.onResetModule(x, y) }\n                        }\n                        return (\n                        <OutputBoardFlap\n                            data={item}\n                            key={`${x}-${y}`}\n                            {...p}\n                        />\n                    )})\n                }\n            </tr>\n        ))\n    }\n    \n    render() {\n        return (\n            <div className=\"output-board-container\">\n                <table className=\"output-board\">\n                    <tbody>\n                        {this.createOutputGrid()}\n                    </tbody>\n                </table>\n            </div>\n        )\n    }\n}\nexport default OutputBoard;\n\n\n","import React, { Component } from \"react\";\nimport { PB } from \"splitflapjs-proto\";\nimport './style.css';\n\nconst PowerChannel = (props) => {\n    return (\n        <div className='power-channel'>\n            <div className={`status status-on-${props.data.on}`}>{props.data.on ? 'ON' : 'OFF'}</div>\n            <div className='voltage'>{props.data.voltageVolts.toFixed(2)} V</div>\n            <div className='current'>{props.data.currentAmps.toFixed(3)} A</div>\n        </div>\n    )\n}\n\nclass SplitflapDiagnostics extends Component {\n    constructor() {\n        super();\n        this.state = {\n            supervisorState: {}\n        };\n    }\n\n    onSupervisorState(state) {\n        this.setState({supervisorState: state})\n    }\n\n    onSplitflapState(state) {\n        this.setState({splitflapState: state})\n    }\n\n    componentDidMount() {\n        this.props.socket.on('splitflap_supervisor_state', (data) => {this.onSupervisorState(data)})\n        this.props.socket.on('splitflap_state', (data) => {this.onSplitflapState(data)})\n    }\n\n    componentWillUnmount() {\n        this.props.socket.off('splitflap_supervisor_state', this.onSupervisorState)\n        this.props.socket.off('splitflap_state', this.onSplitflapState)\n    }\n\n    render() {\n        const supervisorStateObj = PB.SupervisorState.toObject(this.state.supervisorState, {defaults:true, enums: String})\n        return (\n            <div className=\"diagnostics\">\n                <div>Server: {this.props.serverName}</div>\n                <div><button onClick={this.props.onHardResetClick}>Hard Reset Splitflap MCU</button></div>\n                <div>Uptime: {this.state.supervisorState.uptimeMillis}</div>\n                <div>Monitor state: {supervisorStateObj.state}</div>\n                <div style={{display: this.state.supervisorState.state === PB.SupervisorState.State.FAULT ? 'block' : 'none'}}>Fault info:<pre>{JSON.stringify(supervisorStateObj.faultInfo, undefined, 4)}</pre></div>\n                {\n                    supervisorStateObj.powerChannels.map((d, i) => (<PowerChannel data={d} key={i} />))\n                }\n                <div>\n                    <button onClick={this.props.stopAnimation}>STOP</button>\n                    {\n                        ['testAll', 'welcome', 'rain', 'spiral', 'randomFill', 'sequence1', 'wheelOfFortune'].map((a) => (\n                            <button onClick={() => this.props.startAnimation(a)} key={a}>{a}</button>\n                        ))\n                    }\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default SplitflapDiagnostics;\n","import React, { Component } from \"react\";\nimport './style.css';\n\nimport Header from '../Header/';\nimport InputBoard from '../InputBoard/';\nimport OutputBoard from '../OutputBoard/';\nimport SplitflapDiagnostics from '../SplitflapDiagnostics';\n\nclass Main extends Component {\n    constructor() {\n        super();\n        this.state = {\n            boardLayoutData: {\n                modules: Array(108).fill(undefined),\n            },\n            splitflapState: {\n                modules: Array(108).fill(undefined),\n            },\n        };\n    }\n\n    onBoardLayoutUpdate(data) {\n        this.setState({\n            boardLayoutData: {\n                modules: data.map((i) => {\n                    return {\n                        flapIndex: i,\n                    }\n                }),\n            },\n        })\n    }\n\n    componentDidMount() {\n        this.props.socket.on('button down', (data) => {\n            console.log('socket data', data)\n            this.onBoardLayoutUpdate(data.flaps);\n        })\n\n        this.props.socket.on('button up', (data) => {\n            this.onBoardLayoutUpdate(data.flaps);\n        })\n\n        this.props.socket.on('splitflap_state', (data) => {this.setState({splitflapState: data})})\n    }\n\n    componentWillUnmount() {\n        this.props.socket.off('splitflap_state', this.onSplitflapState)\n    }\n    \n    render() {\n        return (\n            <div>\n                <Header />\n                <InputBoard socket={this.props.socket} />\n                <OutputBoard socket={this.props.socket} splitflapState={this.state.boardLayoutData} />\n                <OutputBoard socket={this.props.socket} splitflapState={this.state.splitflapState} onResetModule={this.props.resetModule}/>\n                {/* <SocketTest socket={socket}/> */}\n                <SplitflapDiagnostics serverName={this.props.socket.io.uri} socket={this.props.socket} onHardResetClick={this.props.splitflapHardReset} startAnimation={this.props.startAnimation} stopAnimation={this.props.stopAnimation} />\n            </div>\n        )\n    }\n}\nexport default Main;\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import SocketTest from './components/SocketTest/SocketTest';\nimport Main from './components/Main/';\nimport 'typeface-libre-barcode-128-text';\nimport socketIOClient from \"socket.io-client\";\nimport { apiURL } from './constants';\n//const backendHost = \"http://raspberrypi:8090\"\nconst backendHost = apiURL;\n\n\nconst socket = socketIOClient(backendHost);\n\n// import * as serviceWorker from './serviceWorker';\n\nconst splitflapHardReset = async () => {\n  try {\n    const result = await fetch(new URL('/splitflap/hard_reset', backendHost), {\n      method: 'POST',\n    })\n    alert(await result.text())\n  } catch (err) {\n    alert(err)\n  }\n}\n\nconst resetModule = async (x, y) => {\n  try {\n    const result = await fetch(new URL('/splitflap/reset_module', backendHost), {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({x, y})\n    })\n    console.log(`Reset module result: ${await result.text()}`)\n  } catch (err) {\n    alert(err)\n  }\n}\n\nconst startAnimation = async (animation) => {\n  try {\n    const result = await fetch(new URL('/splitflap/start_animation', backendHost), {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({animation})\n    })\n    console.log(`Start animation result: ${await result.text()}`)\n  } catch (err) {\n    alert(err)\n  }\n}\n\nconst stopAnimation = async () => {\n  try {\n    const result = await fetch(new URL('/splitflap/stop_animation', backendHost), {\n      method: 'POST',\n    })\n    console.log(`Stop animation result: ${await result.text()}`)\n  } catch (err) {\n    alert(err)\n  }\n}\n\nReactDOM.render(\n  <React.StrictMode>\n    <div id='app-content'>\n      <Main socket={socket} splitflapHardReset={splitflapHardReset} resetModule={resetModule} startAnimation={startAnimation} stopAnimation={stopAnimation} />\n    </div>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n","/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (typeof define === 'function' && define.amd)\n        define([\"protobufjs/minimal\"], factory);\n\n    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)\n        module.exports = factory(require(\"protobufjs/minimal\"));\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.PB = (function() {\n    \n        /**\n         * Namespace PB.\n         * @exports PB\n         * @namespace\n         */\n        var PB = {};\n    \n        PB.SplitflapState = (function() {\n    \n            /**\n             * Properties of a SplitflapState.\n             * @memberof PB\n             * @interface ISplitflapState\n             * @property {Array.<PB.SplitflapState.IModuleState>|null} [modules] SplitflapState modules\n             */\n    \n            /**\n             * Constructs a new SplitflapState.\n             * @memberof PB\n             * @classdesc Represents a SplitflapState.\n             * @implements ISplitflapState\n             * @constructor\n             * @param {PB.ISplitflapState=} [properties] Properties to set\n             */\n            function SplitflapState(properties) {\n                this.modules = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SplitflapState modules.\n             * @member {Array.<PB.SplitflapState.IModuleState>} modules\n             * @memberof PB.SplitflapState\n             * @instance\n             */\n            SplitflapState.prototype.modules = $util.emptyArray;\n    \n            /**\n             * Creates a new SplitflapState instance using the specified properties.\n             * @function create\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {PB.ISplitflapState=} [properties] Properties to set\n             * @returns {PB.SplitflapState} SplitflapState instance\n             */\n            SplitflapState.create = function create(properties) {\n                return new SplitflapState(properties);\n            };\n    \n            /**\n             * Encodes the specified SplitflapState message. Does not implicitly {@link PB.SplitflapState.verify|verify} messages.\n             * @function encode\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {PB.ISplitflapState} message SplitflapState message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapState.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.modules != null && message.modules.length)\n                    for (var i = 0; i < message.modules.length; ++i)\n                        $root.PB.SplitflapState.ModuleState.encode(message.modules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SplitflapState message, length delimited. Does not implicitly {@link PB.SplitflapState.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {PB.ISplitflapState} message SplitflapState message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapState.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SplitflapState message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.SplitflapState} SplitflapState\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapState.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapState();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.modules && message.modules.length))\n                            message.modules = [];\n                        message.modules.push($root.PB.SplitflapState.ModuleState.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SplitflapState message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.SplitflapState} SplitflapState\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapState.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SplitflapState message.\n             * @function verify\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SplitflapState.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.modules != null && message.hasOwnProperty(\"modules\")) {\n                    if (!Array.isArray(message.modules))\n                        return \"modules: array expected\";\n                    for (var i = 0; i < message.modules.length; ++i) {\n                        var error = $root.PB.SplitflapState.ModuleState.verify(message.modules[i]);\n                        if (error)\n                            return \"modules.\" + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SplitflapState message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.SplitflapState} SplitflapState\n             */\n            SplitflapState.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.SplitflapState)\n                    return object;\n                var message = new $root.PB.SplitflapState();\n                if (object.modules) {\n                    if (!Array.isArray(object.modules))\n                        throw TypeError(\".PB.SplitflapState.modules: array expected\");\n                    message.modules = [];\n                    for (var i = 0; i < object.modules.length; ++i) {\n                        if (typeof object.modules[i] !== \"object\")\n                            throw TypeError(\".PB.SplitflapState.modules: object expected\");\n                        message.modules[i] = $root.PB.SplitflapState.ModuleState.fromObject(object.modules[i]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SplitflapState message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.SplitflapState\n             * @static\n             * @param {PB.SplitflapState} message SplitflapState\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SplitflapState.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.modules = [];\n                if (message.modules && message.modules.length) {\n                    object.modules = [];\n                    for (var j = 0; j < message.modules.length; ++j)\n                        object.modules[j] = $root.PB.SplitflapState.ModuleState.toObject(message.modules[j], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this SplitflapState to JSON.\n             * @function toJSON\n             * @memberof PB.SplitflapState\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SplitflapState.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            SplitflapState.ModuleState = (function() {\n    \n                /**\n                 * Properties of a ModuleState.\n                 * @memberof PB.SplitflapState\n                 * @interface IModuleState\n                 * @property {PB.SplitflapState.ModuleState.State|null} [state] ModuleState state\n                 * @property {number|null} [flapIndex] ModuleState flapIndex\n                 * @property {boolean|null} [moving] ModuleState moving\n                 * @property {boolean|null} [homeState] ModuleState homeState\n                 * @property {number|null} [countUnexpectedHome] ModuleState countUnexpectedHome\n                 * @property {number|null} [countMissedHome] ModuleState countMissedHome\n                 */\n    \n                /**\n                 * Constructs a new ModuleState.\n                 * @memberof PB.SplitflapState\n                 * @classdesc Represents a ModuleState.\n                 * @implements IModuleState\n                 * @constructor\n                 * @param {PB.SplitflapState.IModuleState=} [properties] Properties to set\n                 */\n                function ModuleState(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ModuleState state.\n                 * @member {PB.SplitflapState.ModuleState.State} state\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.state = 0;\n    \n                /**\n                 * ModuleState flapIndex.\n                 * @member {number} flapIndex\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.flapIndex = 0;\n    \n                /**\n                 * ModuleState moving.\n                 * @member {boolean} moving\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.moving = false;\n    \n                /**\n                 * ModuleState homeState.\n                 * @member {boolean} homeState\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.homeState = false;\n    \n                /**\n                 * ModuleState countUnexpectedHome.\n                 * @member {number} countUnexpectedHome\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.countUnexpectedHome = 0;\n    \n                /**\n                 * ModuleState countMissedHome.\n                 * @member {number} countMissedHome\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 */\n                ModuleState.prototype.countMissedHome = 0;\n    \n                /**\n                 * Creates a new ModuleState instance using the specified properties.\n                 * @function create\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {PB.SplitflapState.IModuleState=} [properties] Properties to set\n                 * @returns {PB.SplitflapState.ModuleState} ModuleState instance\n                 */\n                ModuleState.create = function create(properties) {\n                    return new ModuleState(properties);\n                };\n    \n                /**\n                 * Encodes the specified ModuleState message. Does not implicitly {@link PB.SplitflapState.ModuleState.verify|verify} messages.\n                 * @function encode\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {PB.SplitflapState.IModuleState} message ModuleState message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleState.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);\n                    if (message.flapIndex != null && Object.hasOwnProperty.call(message, \"flapIndex\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flapIndex);\n                    if (message.moving != null && Object.hasOwnProperty.call(message, \"moving\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.moving);\n                    if (message.homeState != null && Object.hasOwnProperty.call(message, \"homeState\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.homeState);\n                    if (message.countUnexpectedHome != null && Object.hasOwnProperty.call(message, \"countUnexpectedHome\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.countUnexpectedHome);\n                    if (message.countMissedHome != null && Object.hasOwnProperty.call(message, \"countMissedHome\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.countMissedHome);\n                    return writer;\n                };\n    \n                /**\n                 * Encodes the specified ModuleState message, length delimited. Does not implicitly {@link PB.SplitflapState.ModuleState.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {PB.SplitflapState.IModuleState} message ModuleState message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleState.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n    \n                /**\n                 * Decodes a ModuleState message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {PB.SplitflapState.ModuleState} ModuleState\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleState.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapState.ModuleState();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.state = reader.int32();\n                            break;\n                        case 2:\n                            message.flapIndex = reader.uint32();\n                            break;\n                        case 3:\n                            message.moving = reader.bool();\n                            break;\n                        case 4:\n                            message.homeState = reader.bool();\n                            break;\n                        case 5:\n                            message.countUnexpectedHome = reader.uint32();\n                            break;\n                        case 6:\n                            message.countMissedHome = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Decodes a ModuleState message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {PB.SplitflapState.ModuleState} ModuleState\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleState.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n    \n                /**\n                 * Verifies a ModuleState message.\n                 * @function verify\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ModuleState.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.state != null && message.hasOwnProperty(\"state\"))\n                        switch (message.state) {\n                        default:\n                            return \"state: enum value expected\";\n                        case 0:\n                        case 1:\n                        case 2:\n                        case 3:\n                        case 4:\n                            break;\n                        }\n                    if (message.flapIndex != null && message.hasOwnProperty(\"flapIndex\"))\n                        if (!$util.isInteger(message.flapIndex))\n                            return \"flapIndex: integer expected\";\n                    if (message.moving != null && message.hasOwnProperty(\"moving\"))\n                        if (typeof message.moving !== \"boolean\")\n                            return \"moving: boolean expected\";\n                    if (message.homeState != null && message.hasOwnProperty(\"homeState\"))\n                        if (typeof message.homeState !== \"boolean\")\n                            return \"homeState: boolean expected\";\n                    if (message.countUnexpectedHome != null && message.hasOwnProperty(\"countUnexpectedHome\"))\n                        if (!$util.isInteger(message.countUnexpectedHome))\n                            return \"countUnexpectedHome: integer expected\";\n                    if (message.countMissedHome != null && message.hasOwnProperty(\"countMissedHome\"))\n                        if (!$util.isInteger(message.countMissedHome))\n                            return \"countMissedHome: integer expected\";\n                    return null;\n                };\n    \n                /**\n                 * Creates a ModuleState message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {PB.SplitflapState.ModuleState} ModuleState\n                 */\n                ModuleState.fromObject = function fromObject(object) {\n                    if (object instanceof $root.PB.SplitflapState.ModuleState)\n                        return object;\n                    var message = new $root.PB.SplitflapState.ModuleState();\n                    switch (object.state) {\n                    case \"NORMAL\":\n                    case 0:\n                        message.state = 0;\n                        break;\n                    case \"LOOK_FOR_HOME\":\n                    case 1:\n                        message.state = 1;\n                        break;\n                    case \"SENSOR_ERROR\":\n                    case 2:\n                        message.state = 2;\n                        break;\n                    case \"PANIC\":\n                    case 3:\n                        message.state = 3;\n                        break;\n                    case \"STATE_DISABLED\":\n                    case 4:\n                        message.state = 4;\n                        break;\n                    }\n                    if (object.flapIndex != null)\n                        message.flapIndex = object.flapIndex >>> 0;\n                    if (object.moving != null)\n                        message.moving = Boolean(object.moving);\n                    if (object.homeState != null)\n                        message.homeState = Boolean(object.homeState);\n                    if (object.countUnexpectedHome != null)\n                        message.countUnexpectedHome = object.countUnexpectedHome >>> 0;\n                    if (object.countMissedHome != null)\n                        message.countMissedHome = object.countMissedHome >>> 0;\n                    return message;\n                };\n    \n                /**\n                 * Creates a plain object from a ModuleState message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @static\n                 * @param {PB.SplitflapState.ModuleState} message ModuleState\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                ModuleState.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.state = options.enums === String ? \"NORMAL\" : 0;\n                        object.flapIndex = 0;\n                        object.moving = false;\n                        object.homeState = false;\n                        object.countUnexpectedHome = 0;\n                        object.countMissedHome = 0;\n                    }\n                    if (message.state != null && message.hasOwnProperty(\"state\"))\n                        object.state = options.enums === String ? $root.PB.SplitflapState.ModuleState.State[message.state] : message.state;\n                    if (message.flapIndex != null && message.hasOwnProperty(\"flapIndex\"))\n                        object.flapIndex = message.flapIndex;\n                    if (message.moving != null && message.hasOwnProperty(\"moving\"))\n                        object.moving = message.moving;\n                    if (message.homeState != null && message.hasOwnProperty(\"homeState\"))\n                        object.homeState = message.homeState;\n                    if (message.countUnexpectedHome != null && message.hasOwnProperty(\"countUnexpectedHome\"))\n                        object.countUnexpectedHome = message.countUnexpectedHome;\n                    if (message.countMissedHome != null && message.hasOwnProperty(\"countMissedHome\"))\n                        object.countMissedHome = message.countMissedHome;\n                    return object;\n                };\n    \n                /**\n                 * Converts this ModuleState to JSON.\n                 * @function toJSON\n                 * @memberof PB.SplitflapState.ModuleState\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                ModuleState.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n    \n                /**\n                 * State enum.\n                 * @name PB.SplitflapState.ModuleState.State\n                 * @enum {number}\n                 * @property {number} NORMAL=0 NORMAL value\n                 * @property {number} LOOK_FOR_HOME=1 LOOK_FOR_HOME value\n                 * @property {number} SENSOR_ERROR=2 SENSOR_ERROR value\n                 * @property {number} PANIC=3 PANIC value\n                 * @property {number} STATE_DISABLED=4 STATE_DISABLED value\n                 */\n                ModuleState.State = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NORMAL\"] = 0;\n                    values[valuesById[1] = \"LOOK_FOR_HOME\"] = 1;\n                    values[valuesById[2] = \"SENSOR_ERROR\"] = 2;\n                    values[valuesById[3] = \"PANIC\"] = 3;\n                    values[valuesById[4] = \"STATE_DISABLED\"] = 4;\n                    return values;\n                })();\n    \n                return ModuleState;\n            })();\n    \n            return SplitflapState;\n        })();\n    \n        PB.Log = (function() {\n    \n            /**\n             * Properties of a Log.\n             * @memberof PB\n             * @interface ILog\n             * @property {string|null} [msg] Log msg\n             */\n    \n            /**\n             * Constructs a new Log.\n             * @memberof PB\n             * @classdesc Represents a Log.\n             * @implements ILog\n             * @constructor\n             * @param {PB.ILog=} [properties] Properties to set\n             */\n            function Log(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Log msg.\n             * @member {string} msg\n             * @memberof PB.Log\n             * @instance\n             */\n            Log.prototype.msg = \"\";\n    \n            /**\n             * Creates a new Log instance using the specified properties.\n             * @function create\n             * @memberof PB.Log\n             * @static\n             * @param {PB.ILog=} [properties] Properties to set\n             * @returns {PB.Log} Log instance\n             */\n            Log.create = function create(properties) {\n                return new Log(properties);\n            };\n    \n            /**\n             * Encodes the specified Log message. Does not implicitly {@link PB.Log.verify|verify} messages.\n             * @function encode\n             * @memberof PB.Log\n             * @static\n             * @param {PB.ILog} message Log message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Log.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.msg != null && Object.hasOwnProperty.call(message, \"msg\"))\n                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.msg);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Log message, length delimited. Does not implicitly {@link PB.Log.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.Log\n             * @static\n             * @param {PB.ILog} message Log message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Log.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a Log message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.Log\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.Log} Log\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Log.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.Log();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.msg = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a Log message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.Log\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.Log} Log\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Log.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a Log message.\n             * @function verify\n             * @memberof PB.Log\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Log.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.msg != null && message.hasOwnProperty(\"msg\"))\n                    if (!$util.isString(message.msg))\n                        return \"msg: string expected\";\n                return null;\n            };\n    \n            /**\n             * Creates a Log message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.Log\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.Log} Log\n             */\n            Log.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.Log)\n                    return object;\n                var message = new $root.PB.Log();\n                if (object.msg != null)\n                    message.msg = String(object.msg);\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a Log message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.Log\n             * @static\n             * @param {PB.Log} message Log\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Log.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.msg = \"\";\n                if (message.msg != null && message.hasOwnProperty(\"msg\"))\n                    object.msg = message.msg;\n                return object;\n            };\n    \n            /**\n             * Converts this Log to JSON.\n             * @function toJSON\n             * @memberof PB.Log\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Log.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Log;\n        })();\n    \n        PB.Ack = (function() {\n    \n            /**\n             * Properties of an Ack.\n             * @memberof PB\n             * @interface IAck\n             * @property {number|null} [nonce] Ack nonce\n             */\n    \n            /**\n             * Constructs a new Ack.\n             * @memberof PB\n             * @classdesc Represents an Ack.\n             * @implements IAck\n             * @constructor\n             * @param {PB.IAck=} [properties] Properties to set\n             */\n            function Ack(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * Ack nonce.\n             * @member {number} nonce\n             * @memberof PB.Ack\n             * @instance\n             */\n            Ack.prototype.nonce = 0;\n    \n            /**\n             * Creates a new Ack instance using the specified properties.\n             * @function create\n             * @memberof PB.Ack\n             * @static\n             * @param {PB.IAck=} [properties] Properties to set\n             * @returns {PB.Ack} Ack instance\n             */\n            Ack.create = function create(properties) {\n                return new Ack(properties);\n            };\n    \n            /**\n             * Encodes the specified Ack message. Does not implicitly {@link PB.Ack.verify|verify} messages.\n             * @function encode\n             * @memberof PB.Ack\n             * @static\n             * @param {PB.IAck} message Ack message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Ack.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nonce != null && Object.hasOwnProperty.call(message, \"nonce\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nonce);\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified Ack message, length delimited. Does not implicitly {@link PB.Ack.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.Ack\n             * @static\n             * @param {PB.IAck} message Ack message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            Ack.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes an Ack message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.Ack\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.Ack} Ack\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Ack.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.Ack();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.nonce = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes an Ack message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.Ack\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.Ack} Ack\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            Ack.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies an Ack message.\n             * @function verify\n             * @memberof PB.Ack\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            Ack.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.nonce != null && message.hasOwnProperty(\"nonce\"))\n                    if (!$util.isInteger(message.nonce))\n                        return \"nonce: integer expected\";\n                return null;\n            };\n    \n            /**\n             * Creates an Ack message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.Ack\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.Ack} Ack\n             */\n            Ack.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.Ack)\n                    return object;\n                var message = new $root.PB.Ack();\n                if (object.nonce != null)\n                    message.nonce = object.nonce >>> 0;\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from an Ack message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.Ack\n             * @static\n             * @param {PB.Ack} message Ack\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            Ack.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.nonce = 0;\n                if (message.nonce != null && message.hasOwnProperty(\"nonce\"))\n                    object.nonce = message.nonce;\n                return object;\n            };\n    \n            /**\n             * Converts this Ack to JSON.\n             * @function toJSON\n             * @memberof PB.Ack\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            Ack.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return Ack;\n        })();\n    \n        PB.SupervisorState = (function() {\n    \n            /**\n             * Properties of a SupervisorState.\n             * @memberof PB\n             * @interface ISupervisorState\n             * @property {number|null} [uptimeMillis] SupervisorState uptimeMillis\n             * @property {PB.SupervisorState.State|null} [state] SupervisorState state\n             * @property {Array.<PB.SupervisorState.IPowerChannelState>|null} [powerChannels] SupervisorState powerChannels\n             * @property {PB.SupervisorState.IFaultInfo|null} [faultInfo] SupervisorState faultInfo\n             */\n    \n            /**\n             * Constructs a new SupervisorState.\n             * @memberof PB\n             * @classdesc Represents a SupervisorState.\n             * @implements ISupervisorState\n             * @constructor\n             * @param {PB.ISupervisorState=} [properties] Properties to set\n             */\n            function SupervisorState(properties) {\n                this.powerChannels = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SupervisorState uptimeMillis.\n             * @member {number} uptimeMillis\n             * @memberof PB.SupervisorState\n             * @instance\n             */\n            SupervisorState.prototype.uptimeMillis = 0;\n    \n            /**\n             * SupervisorState state.\n             * @member {PB.SupervisorState.State} state\n             * @memberof PB.SupervisorState\n             * @instance\n             */\n            SupervisorState.prototype.state = 0;\n    \n            /**\n             * SupervisorState powerChannels.\n             * @member {Array.<PB.SupervisorState.IPowerChannelState>} powerChannels\n             * @memberof PB.SupervisorState\n             * @instance\n             */\n            SupervisorState.prototype.powerChannels = $util.emptyArray;\n    \n            /**\n             * SupervisorState faultInfo.\n             * @member {PB.SupervisorState.IFaultInfo|null|undefined} faultInfo\n             * @memberof PB.SupervisorState\n             * @instance\n             */\n            SupervisorState.prototype.faultInfo = null;\n    \n            /**\n             * Creates a new SupervisorState instance using the specified properties.\n             * @function create\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {PB.ISupervisorState=} [properties] Properties to set\n             * @returns {PB.SupervisorState} SupervisorState instance\n             */\n            SupervisorState.create = function create(properties) {\n                return new SupervisorState(properties);\n            };\n    \n            /**\n             * Encodes the specified SupervisorState message. Does not implicitly {@link PB.SupervisorState.verify|verify} messages.\n             * @function encode\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {PB.ISupervisorState} message SupervisorState message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SupervisorState.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.uptimeMillis != null && Object.hasOwnProperty.call(message, \"uptimeMillis\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.uptimeMillis);\n                if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);\n                if (message.powerChannels != null && message.powerChannels.length)\n                    for (var i = 0; i < message.powerChannels.length; ++i)\n                        $root.PB.SupervisorState.PowerChannelState.encode(message.powerChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.faultInfo != null && Object.hasOwnProperty.call(message, \"faultInfo\"))\n                    $root.PB.SupervisorState.FaultInfo.encode(message.faultInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SupervisorState message, length delimited. Does not implicitly {@link PB.SupervisorState.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {PB.ISupervisorState} message SupervisorState message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SupervisorState.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SupervisorState message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.SupervisorState} SupervisorState\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SupervisorState.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SupervisorState();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.uptimeMillis = reader.uint32();\n                        break;\n                    case 2:\n                        message.state = reader.int32();\n                        break;\n                    case 3:\n                        if (!(message.powerChannels && message.powerChannels.length))\n                            message.powerChannels = [];\n                        message.powerChannels.push($root.PB.SupervisorState.PowerChannelState.decode(reader, reader.uint32()));\n                        break;\n                    case 4:\n                        message.faultInfo = $root.PB.SupervisorState.FaultInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SupervisorState message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.SupervisorState} SupervisorState\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SupervisorState.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SupervisorState message.\n             * @function verify\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SupervisorState.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.uptimeMillis != null && message.hasOwnProperty(\"uptimeMillis\"))\n                    if (!$util.isInteger(message.uptimeMillis))\n                        return \"uptimeMillis: integer expected\";\n                if (message.state != null && message.hasOwnProperty(\"state\"))\n                    switch (message.state) {\n                    default:\n                        return \"state: enum value expected\";\n                    case 0:\n                    case 1:\n                    case 2:\n                    case 3:\n                    case 4:\n                    case 5:\n                        break;\n                    }\n                if (message.powerChannels != null && message.hasOwnProperty(\"powerChannels\")) {\n                    if (!Array.isArray(message.powerChannels))\n                        return \"powerChannels: array expected\";\n                    for (var i = 0; i < message.powerChannels.length; ++i) {\n                        var error = $root.PB.SupervisorState.PowerChannelState.verify(message.powerChannels[i]);\n                        if (error)\n                            return \"powerChannels.\" + error;\n                    }\n                }\n                if (message.faultInfo != null && message.hasOwnProperty(\"faultInfo\")) {\n                    var error = $root.PB.SupervisorState.FaultInfo.verify(message.faultInfo);\n                    if (error)\n                        return \"faultInfo.\" + error;\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SupervisorState message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.SupervisorState} SupervisorState\n             */\n            SupervisorState.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.SupervisorState)\n                    return object;\n                var message = new $root.PB.SupervisorState();\n                if (object.uptimeMillis != null)\n                    message.uptimeMillis = object.uptimeMillis >>> 0;\n                switch (object.state) {\n                case \"UNKNOWN\":\n                case 0:\n                    message.state = 0;\n                    break;\n                case \"STARTING_VERIFY_PSU_OFF\":\n                case 1:\n                    message.state = 1;\n                    break;\n                case \"STARTING_VERIFY_VOLTAGES\":\n                case 2:\n                    message.state = 2;\n                    break;\n                case \"STARTING_ENABLE_CHANNELS\":\n                case 3:\n                    message.state = 3;\n                    break;\n                case \"NORMAL\":\n                case 4:\n                    message.state = 4;\n                    break;\n                case \"FAULT\":\n                case 5:\n                    message.state = 5;\n                    break;\n                }\n                if (object.powerChannels) {\n                    if (!Array.isArray(object.powerChannels))\n                        throw TypeError(\".PB.SupervisorState.powerChannels: array expected\");\n                    message.powerChannels = [];\n                    for (var i = 0; i < object.powerChannels.length; ++i) {\n                        if (typeof object.powerChannels[i] !== \"object\")\n                            throw TypeError(\".PB.SupervisorState.powerChannels: object expected\");\n                        message.powerChannels[i] = $root.PB.SupervisorState.PowerChannelState.fromObject(object.powerChannels[i]);\n                    }\n                }\n                if (object.faultInfo != null) {\n                    if (typeof object.faultInfo !== \"object\")\n                        throw TypeError(\".PB.SupervisorState.faultInfo: object expected\");\n                    message.faultInfo = $root.PB.SupervisorState.FaultInfo.fromObject(object.faultInfo);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SupervisorState message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.SupervisorState\n             * @static\n             * @param {PB.SupervisorState} message SupervisorState\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SupervisorState.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.powerChannels = [];\n                if (options.defaults) {\n                    object.uptimeMillis = 0;\n                    object.state = options.enums === String ? \"UNKNOWN\" : 0;\n                    object.faultInfo = null;\n                }\n                if (message.uptimeMillis != null && message.hasOwnProperty(\"uptimeMillis\"))\n                    object.uptimeMillis = message.uptimeMillis;\n                if (message.state != null && message.hasOwnProperty(\"state\"))\n                    object.state = options.enums === String ? $root.PB.SupervisorState.State[message.state] : message.state;\n                if (message.powerChannels && message.powerChannels.length) {\n                    object.powerChannels = [];\n                    for (var j = 0; j < message.powerChannels.length; ++j)\n                        object.powerChannels[j] = $root.PB.SupervisorState.PowerChannelState.toObject(message.powerChannels[j], options);\n                }\n                if (message.faultInfo != null && message.hasOwnProperty(\"faultInfo\"))\n                    object.faultInfo = $root.PB.SupervisorState.FaultInfo.toObject(message.faultInfo, options);\n                return object;\n            };\n    \n            /**\n             * Converts this SupervisorState to JSON.\n             * @function toJSON\n             * @memberof PB.SupervisorState\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SupervisorState.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            /**\n             * State enum.\n             * @name PB.SupervisorState.State\n             * @enum {number}\n             * @property {number} UNKNOWN=0 UNKNOWN value\n             * @property {number} STARTING_VERIFY_PSU_OFF=1 STARTING_VERIFY_PSU_OFF value\n             * @property {number} STARTING_VERIFY_VOLTAGES=2 STARTING_VERIFY_VOLTAGES value\n             * @property {number} STARTING_ENABLE_CHANNELS=3 STARTING_ENABLE_CHANNELS value\n             * @property {number} NORMAL=4 NORMAL value\n             * @property {number} FAULT=5 FAULT value\n             */\n            SupervisorState.State = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"UNKNOWN\"] = 0;\n                values[valuesById[1] = \"STARTING_VERIFY_PSU_OFF\"] = 1;\n                values[valuesById[2] = \"STARTING_VERIFY_VOLTAGES\"] = 2;\n                values[valuesById[3] = \"STARTING_ENABLE_CHANNELS\"] = 3;\n                values[valuesById[4] = \"NORMAL\"] = 4;\n                values[valuesById[5] = \"FAULT\"] = 5;\n                return values;\n            })();\n    \n            SupervisorState.PowerChannelState = (function() {\n    \n                /**\n                 * Properties of a PowerChannelState.\n                 * @memberof PB.SupervisorState\n                 * @interface IPowerChannelState\n                 * @property {number|null} [voltageVolts] PowerChannelState voltageVolts\n                 * @property {number|null} [currentAmps] PowerChannelState currentAmps\n                 * @property {boolean|null} [on] PowerChannelState on\n                 */\n    \n                /**\n                 * Constructs a new PowerChannelState.\n                 * @memberof PB.SupervisorState\n                 * @classdesc Represents a PowerChannelState.\n                 * @implements IPowerChannelState\n                 * @constructor\n                 * @param {PB.SupervisorState.IPowerChannelState=} [properties] Properties to set\n                 */\n                function PowerChannelState(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * PowerChannelState voltageVolts.\n                 * @member {number} voltageVolts\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @instance\n                 */\n                PowerChannelState.prototype.voltageVolts = 0;\n    \n                /**\n                 * PowerChannelState currentAmps.\n                 * @member {number} currentAmps\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @instance\n                 */\n                PowerChannelState.prototype.currentAmps = 0;\n    \n                /**\n                 * PowerChannelState on.\n                 * @member {boolean} on\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @instance\n                 */\n                PowerChannelState.prototype.on = false;\n    \n                /**\n                 * Creates a new PowerChannelState instance using the specified properties.\n                 * @function create\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {PB.SupervisorState.IPowerChannelState=} [properties] Properties to set\n                 * @returns {PB.SupervisorState.PowerChannelState} PowerChannelState instance\n                 */\n                PowerChannelState.create = function create(properties) {\n                    return new PowerChannelState(properties);\n                };\n    \n                /**\n                 * Encodes the specified PowerChannelState message. Does not implicitly {@link PB.SupervisorState.PowerChannelState.verify|verify} messages.\n                 * @function encode\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {PB.SupervisorState.IPowerChannelState} message PowerChannelState message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PowerChannelState.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.voltageVolts != null && Object.hasOwnProperty.call(message, \"voltageVolts\"))\n                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.voltageVolts);\n                    if (message.currentAmps != null && Object.hasOwnProperty.call(message, \"currentAmps\"))\n                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.currentAmps);\n                    if (message.on != null && Object.hasOwnProperty.call(message, \"on\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.on);\n                    return writer;\n                };\n    \n                /**\n                 * Encodes the specified PowerChannelState message, length delimited. Does not implicitly {@link PB.SupervisorState.PowerChannelState.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {PB.SupervisorState.IPowerChannelState} message PowerChannelState message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                PowerChannelState.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n    \n                /**\n                 * Decodes a PowerChannelState message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {PB.SupervisorState.PowerChannelState} PowerChannelState\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PowerChannelState.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SupervisorState.PowerChannelState();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.voltageVolts = reader.float();\n                            break;\n                        case 2:\n                            message.currentAmps = reader.float();\n                            break;\n                        case 3:\n                            message.on = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Decodes a PowerChannelState message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {PB.SupervisorState.PowerChannelState} PowerChannelState\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                PowerChannelState.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n    \n                /**\n                 * Verifies a PowerChannelState message.\n                 * @function verify\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                PowerChannelState.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.voltageVolts != null && message.hasOwnProperty(\"voltageVolts\"))\n                        if (typeof message.voltageVolts !== \"number\")\n                            return \"voltageVolts: number expected\";\n                    if (message.currentAmps != null && message.hasOwnProperty(\"currentAmps\"))\n                        if (typeof message.currentAmps !== \"number\")\n                            return \"currentAmps: number expected\";\n                    if (message.on != null && message.hasOwnProperty(\"on\"))\n                        if (typeof message.on !== \"boolean\")\n                            return \"on: boolean expected\";\n                    return null;\n                };\n    \n                /**\n                 * Creates a PowerChannelState message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {PB.SupervisorState.PowerChannelState} PowerChannelState\n                 */\n                PowerChannelState.fromObject = function fromObject(object) {\n                    if (object instanceof $root.PB.SupervisorState.PowerChannelState)\n                        return object;\n                    var message = new $root.PB.SupervisorState.PowerChannelState();\n                    if (object.voltageVolts != null)\n                        message.voltageVolts = Number(object.voltageVolts);\n                    if (object.currentAmps != null)\n                        message.currentAmps = Number(object.currentAmps);\n                    if (object.on != null)\n                        message.on = Boolean(object.on);\n                    return message;\n                };\n    \n                /**\n                 * Creates a plain object from a PowerChannelState message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @static\n                 * @param {PB.SupervisorState.PowerChannelState} message PowerChannelState\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                PowerChannelState.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.voltageVolts = 0;\n                        object.currentAmps = 0;\n                        object.on = false;\n                    }\n                    if (message.voltageVolts != null && message.hasOwnProperty(\"voltageVolts\"))\n                        object.voltageVolts = options.json && !isFinite(message.voltageVolts) ? String(message.voltageVolts) : message.voltageVolts;\n                    if (message.currentAmps != null && message.hasOwnProperty(\"currentAmps\"))\n                        object.currentAmps = options.json && !isFinite(message.currentAmps) ? String(message.currentAmps) : message.currentAmps;\n                    if (message.on != null && message.hasOwnProperty(\"on\"))\n                        object.on = message.on;\n                    return object;\n                };\n    \n                /**\n                 * Converts this PowerChannelState to JSON.\n                 * @function toJSON\n                 * @memberof PB.SupervisorState.PowerChannelState\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                PowerChannelState.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n    \n                return PowerChannelState;\n            })();\n    \n            SupervisorState.FaultInfo = (function() {\n    \n                /**\n                 * Properties of a FaultInfo.\n                 * @memberof PB.SupervisorState\n                 * @interface IFaultInfo\n                 * @property {PB.SupervisorState.FaultInfo.FaultType|null} [type] FaultInfo type\n                 * @property {string|null} [msg] FaultInfo msg\n                 * @property {number|null} [tsMillis] FaultInfo tsMillis\n                 */\n    \n                /**\n                 * Constructs a new FaultInfo.\n                 * @memberof PB.SupervisorState\n                 * @classdesc Represents a FaultInfo.\n                 * @implements IFaultInfo\n                 * @constructor\n                 * @param {PB.SupervisorState.IFaultInfo=} [properties] Properties to set\n                 */\n                function FaultInfo(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FaultInfo type.\n                 * @member {PB.SupervisorState.FaultInfo.FaultType} type\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @instance\n                 */\n                FaultInfo.prototype.type = 0;\n    \n                /**\n                 * FaultInfo msg.\n                 * @member {string} msg\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @instance\n                 */\n                FaultInfo.prototype.msg = \"\";\n    \n                /**\n                 * FaultInfo tsMillis.\n                 * @member {number} tsMillis\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @instance\n                 */\n                FaultInfo.prototype.tsMillis = 0;\n    \n                /**\n                 * Creates a new FaultInfo instance using the specified properties.\n                 * @function create\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {PB.SupervisorState.IFaultInfo=} [properties] Properties to set\n                 * @returns {PB.SupervisorState.FaultInfo} FaultInfo instance\n                 */\n                FaultInfo.create = function create(properties) {\n                    return new FaultInfo(properties);\n                };\n    \n                /**\n                 * Encodes the specified FaultInfo message. Does not implicitly {@link PB.SupervisorState.FaultInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {PB.SupervisorState.IFaultInfo} message FaultInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FaultInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.msg != null && Object.hasOwnProperty.call(message, \"msg\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);\n                    if (message.tsMillis != null && Object.hasOwnProperty.call(message, \"tsMillis\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.tsMillis);\n                    return writer;\n                };\n    \n                /**\n                 * Encodes the specified FaultInfo message, length delimited. Does not implicitly {@link PB.SupervisorState.FaultInfo.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {PB.SupervisorState.IFaultInfo} message FaultInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FaultInfo.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n    \n                /**\n                 * Decodes a FaultInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {PB.SupervisorState.FaultInfo} FaultInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FaultInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SupervisorState.FaultInfo();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.msg = reader.string();\n                            break;\n                        case 3:\n                            message.tsMillis = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Decodes a FaultInfo message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {PB.SupervisorState.FaultInfo} FaultInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FaultInfo.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n    \n                /**\n                 * Verifies a FaultInfo message.\n                 * @function verify\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                FaultInfo.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.type != null && message.hasOwnProperty(\"type\"))\n                        switch (message.type) {\n                        default:\n                            return \"type: enum value expected\";\n                        case 0:\n                        case 1:\n                        case 2:\n                        case 3:\n                        case 4:\n                        case 5:\n                        case 6:\n                            break;\n                        }\n                    if (message.msg != null && message.hasOwnProperty(\"msg\"))\n                        if (!$util.isString(message.msg))\n                            return \"msg: string expected\";\n                    if (message.tsMillis != null && message.hasOwnProperty(\"tsMillis\"))\n                        if (!$util.isInteger(message.tsMillis))\n                            return \"tsMillis: integer expected\";\n                    return null;\n                };\n    \n                /**\n                 * Creates a FaultInfo message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {PB.SupervisorState.FaultInfo} FaultInfo\n                 */\n                FaultInfo.fromObject = function fromObject(object) {\n                    if (object instanceof $root.PB.SupervisorState.FaultInfo)\n                        return object;\n                    var message = new $root.PB.SupervisorState.FaultInfo();\n                    switch (object.type) {\n                    case \"UNKNOWN\":\n                    case 0:\n                        message.type = 0;\n                        break;\n                    case \"NONE\":\n                    case 1:\n                        message.type = 1;\n                        break;\n                    case \"INRUSH_CURRENT_NOT_SETTLED\":\n                    case 2:\n                        message.type = 2;\n                        break;\n                    case \"SPLITFLAP_SHUTDOWN\":\n                    case 3:\n                        message.type = 3;\n                        break;\n                    case \"OUT_OF_RANGE\":\n                    case 4:\n                        message.type = 4;\n                        break;\n                    case \"OVER_CURRENT\":\n                    case 5:\n                        message.type = 5;\n                        break;\n                    case \"UNEXPECTED_POWER\":\n                    case 6:\n                        message.type = 6;\n                        break;\n                    }\n                    if (object.msg != null)\n                        message.msg = String(object.msg);\n                    if (object.tsMillis != null)\n                        message.tsMillis = object.tsMillis >>> 0;\n                    return message;\n                };\n    \n                /**\n                 * Creates a plain object from a FaultInfo message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @static\n                 * @param {PB.SupervisorState.FaultInfo} message FaultInfo\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                FaultInfo.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.type = options.enums === String ? \"UNKNOWN\" : 0;\n                        object.msg = \"\";\n                        object.tsMillis = 0;\n                    }\n                    if (message.type != null && message.hasOwnProperty(\"type\"))\n                        object.type = options.enums === String ? $root.PB.SupervisorState.FaultInfo.FaultType[message.type] : message.type;\n                    if (message.msg != null && message.hasOwnProperty(\"msg\"))\n                        object.msg = message.msg;\n                    if (message.tsMillis != null && message.hasOwnProperty(\"tsMillis\"))\n                        object.tsMillis = message.tsMillis;\n                    return object;\n                };\n    \n                /**\n                 * Converts this FaultInfo to JSON.\n                 * @function toJSON\n                 * @memberof PB.SupervisorState.FaultInfo\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                FaultInfo.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n    \n                /**\n                 * FaultType enum.\n                 * @name PB.SupervisorState.FaultInfo.FaultType\n                 * @enum {number}\n                 * @property {number} UNKNOWN=0 UNKNOWN value\n                 * @property {number} NONE=1 NONE value\n                 * @property {number} INRUSH_CURRENT_NOT_SETTLED=2 INRUSH_CURRENT_NOT_SETTLED value\n                 * @property {number} SPLITFLAP_SHUTDOWN=3 SPLITFLAP_SHUTDOWN value\n                 * @property {number} OUT_OF_RANGE=4 OUT_OF_RANGE value\n                 * @property {number} OVER_CURRENT=5 OVER_CURRENT value\n                 * @property {number} UNEXPECTED_POWER=6 UNEXPECTED_POWER value\n                 */\n                FaultInfo.FaultType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"UNKNOWN\"] = 0;\n                    values[valuesById[1] = \"NONE\"] = 1;\n                    values[valuesById[2] = \"INRUSH_CURRENT_NOT_SETTLED\"] = 2;\n                    values[valuesById[3] = \"SPLITFLAP_SHUTDOWN\"] = 3;\n                    values[valuesById[4] = \"OUT_OF_RANGE\"] = 4;\n                    values[valuesById[5] = \"OVER_CURRENT\"] = 5;\n                    values[valuesById[6] = \"UNEXPECTED_POWER\"] = 6;\n                    return values;\n                })();\n    \n                return FaultInfo;\n            })();\n    \n            return SupervisorState;\n        })();\n    \n        PB.FromSplitflap = (function() {\n    \n            /**\n             * Properties of a FromSplitflap.\n             * @memberof PB\n             * @interface IFromSplitflap\n             * @property {PB.ISplitflapState|null} [splitflapState] FromSplitflap splitflapState\n             * @property {PB.ILog|null} [log] FromSplitflap log\n             * @property {PB.IAck|null} [ack] FromSplitflap ack\n             * @property {PB.ISupervisorState|null} [supervisorState] FromSplitflap supervisorState\n             */\n    \n            /**\n             * Constructs a new FromSplitflap.\n             * @memberof PB\n             * @classdesc Represents a FromSplitflap.\n             * @implements IFromSplitflap\n             * @constructor\n             * @param {PB.IFromSplitflap=} [properties] Properties to set\n             */\n            function FromSplitflap(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * FromSplitflap splitflapState.\n             * @member {PB.ISplitflapState|null|undefined} splitflapState\n             * @memberof PB.FromSplitflap\n             * @instance\n             */\n            FromSplitflap.prototype.splitflapState = null;\n    \n            /**\n             * FromSplitflap log.\n             * @member {PB.ILog|null|undefined} log\n             * @memberof PB.FromSplitflap\n             * @instance\n             */\n            FromSplitflap.prototype.log = null;\n    \n            /**\n             * FromSplitflap ack.\n             * @member {PB.IAck|null|undefined} ack\n             * @memberof PB.FromSplitflap\n             * @instance\n             */\n            FromSplitflap.prototype.ack = null;\n    \n            /**\n             * FromSplitflap supervisorState.\n             * @member {PB.ISupervisorState|null|undefined} supervisorState\n             * @memberof PB.FromSplitflap\n             * @instance\n             */\n            FromSplitflap.prototype.supervisorState = null;\n    \n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n    \n            /**\n             * FromSplitflap payload.\n             * @member {\"splitflapState\"|\"log\"|\"ack\"|\"supervisorState\"|undefined} payload\n             * @memberof PB.FromSplitflap\n             * @instance\n             */\n            Object.defineProperty(FromSplitflap.prototype, \"payload\", {\n                get: $util.oneOfGetter($oneOfFields = [\"splitflapState\", \"log\", \"ack\", \"supervisorState\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n    \n            /**\n             * Creates a new FromSplitflap instance using the specified properties.\n             * @function create\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {PB.IFromSplitflap=} [properties] Properties to set\n             * @returns {PB.FromSplitflap} FromSplitflap instance\n             */\n            FromSplitflap.create = function create(properties) {\n                return new FromSplitflap(properties);\n            };\n    \n            /**\n             * Encodes the specified FromSplitflap message. Does not implicitly {@link PB.FromSplitflap.verify|verify} messages.\n             * @function encode\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {PB.IFromSplitflap} message FromSplitflap message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FromSplitflap.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.splitflapState != null && Object.hasOwnProperty.call(message, \"splitflapState\"))\n                    $root.PB.SplitflapState.encode(message.splitflapState, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                if (message.log != null && Object.hasOwnProperty.call(message, \"log\"))\n                    $root.PB.Log.encode(message.log, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.ack != null && Object.hasOwnProperty.call(message, \"ack\"))\n                    $root.PB.Ack.encode(message.ack, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                if (message.supervisorState != null && Object.hasOwnProperty.call(message, \"supervisorState\"))\n                    $root.PB.SupervisorState.encode(message.supervisorState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified FromSplitflap message, length delimited. Does not implicitly {@link PB.FromSplitflap.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {PB.IFromSplitflap} message FromSplitflap message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            FromSplitflap.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a FromSplitflap message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.FromSplitflap} FromSplitflap\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FromSplitflap.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.FromSplitflap();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.splitflapState = $root.PB.SplitflapState.decode(reader, reader.uint32());\n                        break;\n                    case 2:\n                        message.log = $root.PB.Log.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.ack = $root.PB.Ack.decode(reader, reader.uint32());\n                        break;\n                    case 4:\n                        message.supervisorState = $root.PB.SupervisorState.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a FromSplitflap message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.FromSplitflap} FromSplitflap\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FromSplitflap.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a FromSplitflap message.\n             * @function verify\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            FromSplitflap.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                var properties = {};\n                if (message.splitflapState != null && message.hasOwnProperty(\"splitflapState\")) {\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.SplitflapState.verify(message.splitflapState);\n                        if (error)\n                            return \"splitflapState.\" + error;\n                    }\n                }\n                if (message.log != null && message.hasOwnProperty(\"log\")) {\n                    if (properties.payload === 1)\n                        return \"payload: multiple values\";\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.Log.verify(message.log);\n                        if (error)\n                            return \"log.\" + error;\n                    }\n                }\n                if (message.ack != null && message.hasOwnProperty(\"ack\")) {\n                    if (properties.payload === 1)\n                        return \"payload: multiple values\";\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.Ack.verify(message.ack);\n                        if (error)\n                            return \"ack.\" + error;\n                    }\n                }\n                if (message.supervisorState != null && message.hasOwnProperty(\"supervisorState\")) {\n                    if (properties.payload === 1)\n                        return \"payload: multiple values\";\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.SupervisorState.verify(message.supervisorState);\n                        if (error)\n                            return \"supervisorState.\" + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a FromSplitflap message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.FromSplitflap} FromSplitflap\n             */\n            FromSplitflap.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.FromSplitflap)\n                    return object;\n                var message = new $root.PB.FromSplitflap();\n                if (object.splitflapState != null) {\n                    if (typeof object.splitflapState !== \"object\")\n                        throw TypeError(\".PB.FromSplitflap.splitflapState: object expected\");\n                    message.splitflapState = $root.PB.SplitflapState.fromObject(object.splitflapState);\n                }\n                if (object.log != null) {\n                    if (typeof object.log !== \"object\")\n                        throw TypeError(\".PB.FromSplitflap.log: object expected\");\n                    message.log = $root.PB.Log.fromObject(object.log);\n                }\n                if (object.ack != null) {\n                    if (typeof object.ack !== \"object\")\n                        throw TypeError(\".PB.FromSplitflap.ack: object expected\");\n                    message.ack = $root.PB.Ack.fromObject(object.ack);\n                }\n                if (object.supervisorState != null) {\n                    if (typeof object.supervisorState !== \"object\")\n                        throw TypeError(\".PB.FromSplitflap.supervisorState: object expected\");\n                    message.supervisorState = $root.PB.SupervisorState.fromObject(object.supervisorState);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a FromSplitflap message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.FromSplitflap\n             * @static\n             * @param {PB.FromSplitflap} message FromSplitflap\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            FromSplitflap.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (message.splitflapState != null && message.hasOwnProperty(\"splitflapState\")) {\n                    object.splitflapState = $root.PB.SplitflapState.toObject(message.splitflapState, options);\n                    if (options.oneofs)\n                        object.payload = \"splitflapState\";\n                }\n                if (message.log != null && message.hasOwnProperty(\"log\")) {\n                    object.log = $root.PB.Log.toObject(message.log, options);\n                    if (options.oneofs)\n                        object.payload = \"log\";\n                }\n                if (message.ack != null && message.hasOwnProperty(\"ack\")) {\n                    object.ack = $root.PB.Ack.toObject(message.ack, options);\n                    if (options.oneofs)\n                        object.payload = \"ack\";\n                }\n                if (message.supervisorState != null && message.hasOwnProperty(\"supervisorState\")) {\n                    object.supervisorState = $root.PB.SupervisorState.toObject(message.supervisorState, options);\n                    if (options.oneofs)\n                        object.payload = \"supervisorState\";\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this FromSplitflap to JSON.\n             * @function toJSON\n             * @memberof PB.FromSplitflap\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            FromSplitflap.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return FromSplitflap;\n        })();\n    \n        PB.SplitflapCommand = (function() {\n    \n            /**\n             * Properties of a SplitflapCommand.\n             * @memberof PB\n             * @interface ISplitflapCommand\n             * @property {Array.<PB.SplitflapCommand.IModuleCommand>|null} [modules] SplitflapCommand modules\n             */\n    \n            /**\n             * Constructs a new SplitflapCommand.\n             * @memberof PB\n             * @classdesc Represents a SplitflapCommand.\n             * @implements ISplitflapCommand\n             * @constructor\n             * @param {PB.ISplitflapCommand=} [properties] Properties to set\n             */\n            function SplitflapCommand(properties) {\n                this.modules = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SplitflapCommand modules.\n             * @member {Array.<PB.SplitflapCommand.IModuleCommand>} modules\n             * @memberof PB.SplitflapCommand\n             * @instance\n             */\n            SplitflapCommand.prototype.modules = $util.emptyArray;\n    \n            /**\n             * Creates a new SplitflapCommand instance using the specified properties.\n             * @function create\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {PB.ISplitflapCommand=} [properties] Properties to set\n             * @returns {PB.SplitflapCommand} SplitflapCommand instance\n             */\n            SplitflapCommand.create = function create(properties) {\n                return new SplitflapCommand(properties);\n            };\n    \n            /**\n             * Encodes the specified SplitflapCommand message. Does not implicitly {@link PB.SplitflapCommand.verify|verify} messages.\n             * @function encode\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {PB.ISplitflapCommand} message SplitflapCommand message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapCommand.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.modules != null && message.modules.length)\n                    for (var i = 0; i < message.modules.length; ++i)\n                        $root.PB.SplitflapCommand.ModuleCommand.encode(message.modules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SplitflapCommand message, length delimited. Does not implicitly {@link PB.SplitflapCommand.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {PB.ISplitflapCommand} message SplitflapCommand message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapCommand.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SplitflapCommand message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.SplitflapCommand} SplitflapCommand\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapCommand.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapCommand();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 2:\n                        if (!(message.modules && message.modules.length))\n                            message.modules = [];\n                        message.modules.push($root.PB.SplitflapCommand.ModuleCommand.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SplitflapCommand message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.SplitflapCommand} SplitflapCommand\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapCommand.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SplitflapCommand message.\n             * @function verify\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SplitflapCommand.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.modules != null && message.hasOwnProperty(\"modules\")) {\n                    if (!Array.isArray(message.modules))\n                        return \"modules: array expected\";\n                    for (var i = 0; i < message.modules.length; ++i) {\n                        var error = $root.PB.SplitflapCommand.ModuleCommand.verify(message.modules[i]);\n                        if (error)\n                            return \"modules.\" + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SplitflapCommand message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.SplitflapCommand} SplitflapCommand\n             */\n            SplitflapCommand.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.SplitflapCommand)\n                    return object;\n                var message = new $root.PB.SplitflapCommand();\n                if (object.modules) {\n                    if (!Array.isArray(object.modules))\n                        throw TypeError(\".PB.SplitflapCommand.modules: array expected\");\n                    message.modules = [];\n                    for (var i = 0; i < object.modules.length; ++i) {\n                        if (typeof object.modules[i] !== \"object\")\n                            throw TypeError(\".PB.SplitflapCommand.modules: object expected\");\n                        message.modules[i] = $root.PB.SplitflapCommand.ModuleCommand.fromObject(object.modules[i]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SplitflapCommand message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.SplitflapCommand\n             * @static\n             * @param {PB.SplitflapCommand} message SplitflapCommand\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SplitflapCommand.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.modules = [];\n                if (message.modules && message.modules.length) {\n                    object.modules = [];\n                    for (var j = 0; j < message.modules.length; ++j)\n                        object.modules[j] = $root.PB.SplitflapCommand.ModuleCommand.toObject(message.modules[j], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this SplitflapCommand to JSON.\n             * @function toJSON\n             * @memberof PB.SplitflapCommand\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SplitflapCommand.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            SplitflapCommand.ModuleCommand = (function() {\n    \n                /**\n                 * Properties of a ModuleCommand.\n                 * @memberof PB.SplitflapCommand\n                 * @interface IModuleCommand\n                 * @property {PB.SplitflapCommand.ModuleCommand.Action|null} [action] ModuleCommand action\n                 * @property {number|null} [param] ModuleCommand param\n                 */\n    \n                /**\n                 * Constructs a new ModuleCommand.\n                 * @memberof PB.SplitflapCommand\n                 * @classdesc Represents a ModuleCommand.\n                 * @implements IModuleCommand\n                 * @constructor\n                 * @param {PB.SplitflapCommand.IModuleCommand=} [properties] Properties to set\n                 */\n                function ModuleCommand(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ModuleCommand action.\n                 * @member {PB.SplitflapCommand.ModuleCommand.Action} action\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @instance\n                 */\n                ModuleCommand.prototype.action = 0;\n    \n                /**\n                 * ModuleCommand param.\n                 * @member {number} param\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @instance\n                 */\n                ModuleCommand.prototype.param = 0;\n    \n                /**\n                 * Creates a new ModuleCommand instance using the specified properties.\n                 * @function create\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {PB.SplitflapCommand.IModuleCommand=} [properties] Properties to set\n                 * @returns {PB.SplitflapCommand.ModuleCommand} ModuleCommand instance\n                 */\n                ModuleCommand.create = function create(properties) {\n                    return new ModuleCommand(properties);\n                };\n    \n                /**\n                 * Encodes the specified ModuleCommand message. Does not implicitly {@link PB.SplitflapCommand.ModuleCommand.verify|verify} messages.\n                 * @function encode\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {PB.SplitflapCommand.IModuleCommand} message ModuleCommand message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleCommand.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.action != null && Object.hasOwnProperty.call(message, \"action\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);\n                    if (message.param != null && Object.hasOwnProperty.call(message, \"param\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.param);\n                    return writer;\n                };\n    \n                /**\n                 * Encodes the specified ModuleCommand message, length delimited. Does not implicitly {@link PB.SplitflapCommand.ModuleCommand.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {PB.SplitflapCommand.IModuleCommand} message ModuleCommand message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleCommand.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n    \n                /**\n                 * Decodes a ModuleCommand message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {PB.SplitflapCommand.ModuleCommand} ModuleCommand\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleCommand.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapCommand.ModuleCommand();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.action = reader.int32();\n                            break;\n                        case 2:\n                            message.param = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Decodes a ModuleCommand message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {PB.SplitflapCommand.ModuleCommand} ModuleCommand\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleCommand.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n    \n                /**\n                 * Verifies a ModuleCommand message.\n                 * @function verify\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ModuleCommand.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.action != null && message.hasOwnProperty(\"action\"))\n                        switch (message.action) {\n                        default:\n                            return \"action: enum value expected\";\n                        case 0:\n                        case 1:\n                        case 2:\n                            break;\n                        }\n                    if (message.param != null && message.hasOwnProperty(\"param\"))\n                        if (!$util.isInteger(message.param))\n                            return \"param: integer expected\";\n                    return null;\n                };\n    \n                /**\n                 * Creates a ModuleCommand message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {PB.SplitflapCommand.ModuleCommand} ModuleCommand\n                 */\n                ModuleCommand.fromObject = function fromObject(object) {\n                    if (object instanceof $root.PB.SplitflapCommand.ModuleCommand)\n                        return object;\n                    var message = new $root.PB.SplitflapCommand.ModuleCommand();\n                    switch (object.action) {\n                    case \"NO_OP\":\n                    case 0:\n                        message.action = 0;\n                        break;\n                    case \"GO_TO_FLAP\":\n                    case 1:\n                        message.action = 1;\n                        break;\n                    case \"RESET_AND_HOME\":\n                    case 2:\n                        message.action = 2;\n                        break;\n                    }\n                    if (object.param != null)\n                        message.param = object.param >>> 0;\n                    return message;\n                };\n    \n                /**\n                 * Creates a plain object from a ModuleCommand message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @static\n                 * @param {PB.SplitflapCommand.ModuleCommand} message ModuleCommand\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                ModuleCommand.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.action = options.enums === String ? \"NO_OP\" : 0;\n                        object.param = 0;\n                    }\n                    if (message.action != null && message.hasOwnProperty(\"action\"))\n                        object.action = options.enums === String ? $root.PB.SplitflapCommand.ModuleCommand.Action[message.action] : message.action;\n                    if (message.param != null && message.hasOwnProperty(\"param\"))\n                        object.param = message.param;\n                    return object;\n                };\n    \n                /**\n                 * Converts this ModuleCommand to JSON.\n                 * @function toJSON\n                 * @memberof PB.SplitflapCommand.ModuleCommand\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                ModuleCommand.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n    \n                /**\n                 * Action enum.\n                 * @name PB.SplitflapCommand.ModuleCommand.Action\n                 * @enum {number}\n                 * @property {number} NO_OP=0 NO_OP value\n                 * @property {number} GO_TO_FLAP=1 GO_TO_FLAP value\n                 * @property {number} RESET_AND_HOME=2 RESET_AND_HOME value\n                 */\n                ModuleCommand.Action = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_OP\"] = 0;\n                    values[valuesById[1] = \"GO_TO_FLAP\"] = 1;\n                    values[valuesById[2] = \"RESET_AND_HOME\"] = 2;\n                    return values;\n                })();\n    \n                return ModuleCommand;\n            })();\n    \n            return SplitflapCommand;\n        })();\n    \n        PB.SplitflapConfig = (function() {\n    \n            /**\n             * Properties of a SplitflapConfig.\n             * @memberof PB\n             * @interface ISplitflapConfig\n             * @property {Array.<PB.SplitflapConfig.IModuleConfig>|null} [modules] SplitflapConfig modules\n             */\n    \n            /**\n             * Constructs a new SplitflapConfig.\n             * @memberof PB\n             * @classdesc Represents a SplitflapConfig.\n             * @implements ISplitflapConfig\n             * @constructor\n             * @param {PB.ISplitflapConfig=} [properties] Properties to set\n             */\n            function SplitflapConfig(properties) {\n                this.modules = [];\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * SplitflapConfig modules.\n             * @member {Array.<PB.SplitflapConfig.IModuleConfig>} modules\n             * @memberof PB.SplitflapConfig\n             * @instance\n             */\n            SplitflapConfig.prototype.modules = $util.emptyArray;\n    \n            /**\n             * Creates a new SplitflapConfig instance using the specified properties.\n             * @function create\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {PB.ISplitflapConfig=} [properties] Properties to set\n             * @returns {PB.SplitflapConfig} SplitflapConfig instance\n             */\n            SplitflapConfig.create = function create(properties) {\n                return new SplitflapConfig(properties);\n            };\n    \n            /**\n             * Encodes the specified SplitflapConfig message. Does not implicitly {@link PB.SplitflapConfig.verify|verify} messages.\n             * @function encode\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {PB.ISplitflapConfig} message SplitflapConfig message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapConfig.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.modules != null && message.modules.length)\n                    for (var i = 0; i < message.modules.length; ++i)\n                        $root.PB.SplitflapConfig.ModuleConfig.encode(message.modules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified SplitflapConfig message, length delimited. Does not implicitly {@link PB.SplitflapConfig.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {PB.ISplitflapConfig} message SplitflapConfig message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            SplitflapConfig.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a SplitflapConfig message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.SplitflapConfig} SplitflapConfig\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapConfig.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapConfig();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.modules && message.modules.length))\n                            message.modules = [];\n                        message.modules.push($root.PB.SplitflapConfig.ModuleConfig.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a SplitflapConfig message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.SplitflapConfig} SplitflapConfig\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SplitflapConfig.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a SplitflapConfig message.\n             * @function verify\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            SplitflapConfig.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                if (message.modules != null && message.hasOwnProperty(\"modules\")) {\n                    if (!Array.isArray(message.modules))\n                        return \"modules: array expected\";\n                    for (var i = 0; i < message.modules.length; ++i) {\n                        var error = $root.PB.SplitflapConfig.ModuleConfig.verify(message.modules[i]);\n                        if (error)\n                            return \"modules.\" + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a SplitflapConfig message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.SplitflapConfig} SplitflapConfig\n             */\n            SplitflapConfig.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.SplitflapConfig)\n                    return object;\n                var message = new $root.PB.SplitflapConfig();\n                if (object.modules) {\n                    if (!Array.isArray(object.modules))\n                        throw TypeError(\".PB.SplitflapConfig.modules: array expected\");\n                    message.modules = [];\n                    for (var i = 0; i < object.modules.length; ++i) {\n                        if (typeof object.modules[i] !== \"object\")\n                            throw TypeError(\".PB.SplitflapConfig.modules: object expected\");\n                        message.modules[i] = $root.PB.SplitflapConfig.ModuleConfig.fromObject(object.modules[i]);\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a SplitflapConfig message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.SplitflapConfig\n             * @static\n             * @param {PB.SplitflapConfig} message SplitflapConfig\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            SplitflapConfig.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.arrays || options.defaults)\n                    object.modules = [];\n                if (message.modules && message.modules.length) {\n                    object.modules = [];\n                    for (var j = 0; j < message.modules.length; ++j)\n                        object.modules[j] = $root.PB.SplitflapConfig.ModuleConfig.toObject(message.modules[j], options);\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this SplitflapConfig to JSON.\n             * @function toJSON\n             * @memberof PB.SplitflapConfig\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            SplitflapConfig.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            SplitflapConfig.ModuleConfig = (function() {\n    \n                /**\n                 * Properties of a ModuleConfig.\n                 * @memberof PB.SplitflapConfig\n                 * @interface IModuleConfig\n                 * @property {number|null} [targetFlapIndex] ModuleConfig targetFlapIndex\n                 * @property {number|null} [movementNonce] Value that triggers a movement upon change. If unused, only changes to target_flap_index\n                 * will trigger a movement. This can be used to trigger a full revolution back to the *same*\n                 * flap index.\n                 * \n                 * NOTE: Must be < 256\n                 * @property {number|null} [resetNonce] Value that triggers a reset (clear error counters, re-home) upon change. If unused,\n                 * module will only re-home upon recoverable errors, and error counters will continue\n                 * to increase until overflow.\n                 * \n                 * NOTE: Must be < 256\n                 */\n    \n                /**\n                 * Constructs a new ModuleConfig.\n                 * @memberof PB.SplitflapConfig\n                 * @classdesc Represents a ModuleConfig.\n                 * @implements IModuleConfig\n                 * @constructor\n                 * @param {PB.SplitflapConfig.IModuleConfig=} [properties] Properties to set\n                 */\n                function ModuleConfig(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ModuleConfig targetFlapIndex.\n                 * @member {number} targetFlapIndex\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @instance\n                 */\n                ModuleConfig.prototype.targetFlapIndex = 0;\n    \n                /**\n                 * Value that triggers a movement upon change. If unused, only changes to target_flap_index\n                 * will trigger a movement. This can be used to trigger a full revolution back to the *same*\n                 * flap index.\n                 * \n                 * NOTE: Must be < 256\n                 * @member {number} movementNonce\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @instance\n                 */\n                ModuleConfig.prototype.movementNonce = 0;\n    \n                /**\n                 * Value that triggers a reset (clear error counters, re-home) upon change. If unused,\n                 * module will only re-home upon recoverable errors, and error counters will continue\n                 * to increase until overflow.\n                 * \n                 * NOTE: Must be < 256\n                 * @member {number} resetNonce\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @instance\n                 */\n                ModuleConfig.prototype.resetNonce = 0;\n    \n                /**\n                 * Creates a new ModuleConfig instance using the specified properties.\n                 * @function create\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {PB.SplitflapConfig.IModuleConfig=} [properties] Properties to set\n                 * @returns {PB.SplitflapConfig.ModuleConfig} ModuleConfig instance\n                 */\n                ModuleConfig.create = function create(properties) {\n                    return new ModuleConfig(properties);\n                };\n    \n                /**\n                 * Encodes the specified ModuleConfig message. Does not implicitly {@link PB.SplitflapConfig.ModuleConfig.verify|verify} messages.\n                 * @function encode\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {PB.SplitflapConfig.IModuleConfig} message ModuleConfig message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleConfig.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.targetFlapIndex != null && Object.hasOwnProperty.call(message, \"targetFlapIndex\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.targetFlapIndex);\n                    if (message.movementNonce != null && Object.hasOwnProperty.call(message, \"movementNonce\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.movementNonce);\n                    if (message.resetNonce != null && Object.hasOwnProperty.call(message, \"resetNonce\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.resetNonce);\n                    return writer;\n                };\n    \n                /**\n                 * Encodes the specified ModuleConfig message, length delimited. Does not implicitly {@link PB.SplitflapConfig.ModuleConfig.verify|verify} messages.\n                 * @function encodeDelimited\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {PB.SplitflapConfig.IModuleConfig} message ModuleConfig message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ModuleConfig.encodeDelimited = function encodeDelimited(message, writer) {\n                    return this.encode(message, writer).ldelim();\n                };\n    \n                /**\n                 * Decodes a ModuleConfig message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {PB.SplitflapConfig.ModuleConfig} ModuleConfig\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleConfig.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.SplitflapConfig.ModuleConfig();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.targetFlapIndex = reader.uint32();\n                            break;\n                        case 2:\n                            message.movementNonce = reader.uint32();\n                            break;\n                        case 3:\n                            message.resetNonce = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Decodes a ModuleConfig message from the specified reader or buffer, length delimited.\n                 * @function decodeDelimited\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @returns {PB.SplitflapConfig.ModuleConfig} ModuleConfig\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ModuleConfig.decodeDelimited = function decodeDelimited(reader) {\n                    if (!(reader instanceof $Reader))\n                        reader = new $Reader(reader);\n                    return this.decode(reader, reader.uint32());\n                };\n    \n                /**\n                 * Verifies a ModuleConfig message.\n                 * @function verify\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {Object.<string,*>} message Plain object to verify\n                 * @returns {string|null} `null` if valid, otherwise the reason why it is not\n                 */\n                ModuleConfig.verify = function verify(message) {\n                    if (typeof message !== \"object\" || message === null)\n                        return \"object expected\";\n                    if (message.targetFlapIndex != null && message.hasOwnProperty(\"targetFlapIndex\"))\n                        if (!$util.isInteger(message.targetFlapIndex))\n                            return \"targetFlapIndex: integer expected\";\n                    if (message.movementNonce != null && message.hasOwnProperty(\"movementNonce\"))\n                        if (!$util.isInteger(message.movementNonce))\n                            return \"movementNonce: integer expected\";\n                    if (message.resetNonce != null && message.hasOwnProperty(\"resetNonce\"))\n                        if (!$util.isInteger(message.resetNonce))\n                            return \"resetNonce: integer expected\";\n                    return null;\n                };\n    \n                /**\n                 * Creates a ModuleConfig message from a plain object. Also converts values to their respective internal types.\n                 * @function fromObject\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {Object.<string,*>} object Plain object\n                 * @returns {PB.SplitflapConfig.ModuleConfig} ModuleConfig\n                 */\n                ModuleConfig.fromObject = function fromObject(object) {\n                    if (object instanceof $root.PB.SplitflapConfig.ModuleConfig)\n                        return object;\n                    var message = new $root.PB.SplitflapConfig.ModuleConfig();\n                    if (object.targetFlapIndex != null)\n                        message.targetFlapIndex = object.targetFlapIndex >>> 0;\n                    if (object.movementNonce != null)\n                        message.movementNonce = object.movementNonce >>> 0;\n                    if (object.resetNonce != null)\n                        message.resetNonce = object.resetNonce >>> 0;\n                    return message;\n                };\n    \n                /**\n                 * Creates a plain object from a ModuleConfig message. Also converts values to other types if specified.\n                 * @function toObject\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @static\n                 * @param {PB.SplitflapConfig.ModuleConfig} message ModuleConfig\n                 * @param {$protobuf.IConversionOptions} [options] Conversion options\n                 * @returns {Object.<string,*>} Plain object\n                 */\n                ModuleConfig.toObject = function toObject(message, options) {\n                    if (!options)\n                        options = {};\n                    var object = {};\n                    if (options.defaults) {\n                        object.targetFlapIndex = 0;\n                        object.movementNonce = 0;\n                        object.resetNonce = 0;\n                    }\n                    if (message.targetFlapIndex != null && message.hasOwnProperty(\"targetFlapIndex\"))\n                        object.targetFlapIndex = message.targetFlapIndex;\n                    if (message.movementNonce != null && message.hasOwnProperty(\"movementNonce\"))\n                        object.movementNonce = message.movementNonce;\n                    if (message.resetNonce != null && message.hasOwnProperty(\"resetNonce\"))\n                        object.resetNonce = message.resetNonce;\n                    return object;\n                };\n    \n                /**\n                 * Converts this ModuleConfig to JSON.\n                 * @function toJSON\n                 * @memberof PB.SplitflapConfig.ModuleConfig\n                 * @instance\n                 * @returns {Object.<string,*>} JSON object\n                 */\n                ModuleConfig.prototype.toJSON = function toJSON() {\n                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n                };\n    \n                return ModuleConfig;\n            })();\n    \n            return SplitflapConfig;\n        })();\n    \n        PB.ToSplitflap = (function() {\n    \n            /**\n             * Properties of a ToSplitflap.\n             * @memberof PB\n             * @interface IToSplitflap\n             * @property {number|null} [nonce] ToSplitflap nonce\n             * @property {PB.ISplitflapCommand|null} [splitflapCommand] ToSplitflap splitflapCommand\n             * @property {PB.ISplitflapConfig|null} [splitflapConfig] ToSplitflap splitflapConfig\n             */\n    \n            /**\n             * Constructs a new ToSplitflap.\n             * @memberof PB\n             * @classdesc Represents a ToSplitflap.\n             * @implements IToSplitflap\n             * @constructor\n             * @param {PB.IToSplitflap=} [properties] Properties to set\n             */\n            function ToSplitflap(properties) {\n                if (properties)\n                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n    \n            /**\n             * ToSplitflap nonce.\n             * @member {number} nonce\n             * @memberof PB.ToSplitflap\n             * @instance\n             */\n            ToSplitflap.prototype.nonce = 0;\n    \n            /**\n             * ToSplitflap splitflapCommand.\n             * @member {PB.ISplitflapCommand|null|undefined} splitflapCommand\n             * @memberof PB.ToSplitflap\n             * @instance\n             */\n            ToSplitflap.prototype.splitflapCommand = null;\n    \n            /**\n             * ToSplitflap splitflapConfig.\n             * @member {PB.ISplitflapConfig|null|undefined} splitflapConfig\n             * @memberof PB.ToSplitflap\n             * @instance\n             */\n            ToSplitflap.prototype.splitflapConfig = null;\n    \n            // OneOf field names bound to virtual getters and setters\n            var $oneOfFields;\n    \n            /**\n             * ToSplitflap payload.\n             * @member {\"splitflapCommand\"|\"splitflapConfig\"|undefined} payload\n             * @memberof PB.ToSplitflap\n             * @instance\n             */\n            Object.defineProperty(ToSplitflap.prototype, \"payload\", {\n                get: $util.oneOfGetter($oneOfFields = [\"splitflapCommand\", \"splitflapConfig\"]),\n                set: $util.oneOfSetter($oneOfFields)\n            });\n    \n            /**\n             * Creates a new ToSplitflap instance using the specified properties.\n             * @function create\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {PB.IToSplitflap=} [properties] Properties to set\n             * @returns {PB.ToSplitflap} ToSplitflap instance\n             */\n            ToSplitflap.create = function create(properties) {\n                return new ToSplitflap(properties);\n            };\n    \n            /**\n             * Encodes the specified ToSplitflap message. Does not implicitly {@link PB.ToSplitflap.verify|verify} messages.\n             * @function encode\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {PB.IToSplitflap} message ToSplitflap message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ToSplitflap.encode = function encode(message, writer) {\n                if (!writer)\n                    writer = $Writer.create();\n                if (message.nonce != null && Object.hasOwnProperty.call(message, \"nonce\"))\n                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.nonce);\n                if (message.splitflapCommand != null && Object.hasOwnProperty.call(message, \"splitflapCommand\"))\n                    $root.PB.SplitflapCommand.encode(message.splitflapCommand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                if (message.splitflapConfig != null && Object.hasOwnProperty.call(message, \"splitflapConfig\"))\n                    $root.PB.SplitflapConfig.encode(message.splitflapConfig, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                return writer;\n            };\n    \n            /**\n             * Encodes the specified ToSplitflap message, length delimited. Does not implicitly {@link PB.ToSplitflap.verify|verify} messages.\n             * @function encodeDelimited\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {PB.IToSplitflap} message ToSplitflap message or plain object to encode\n             * @param {$protobuf.Writer} [writer] Writer to encode to\n             * @returns {$protobuf.Writer} Writer\n             */\n            ToSplitflap.encodeDelimited = function encodeDelimited(message, writer) {\n                return this.encode(message, writer).ldelim();\n            };\n    \n            /**\n             * Decodes a ToSplitflap message from the specified reader or buffer.\n             * @function decode\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {PB.ToSplitflap} ToSplitflap\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ToSplitflap.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PB.ToSplitflap();\n                while (reader.pos < end) {\n                    var tag = reader.uint32();\n                    switch (tag >>> 3) {\n                    case 1:\n                        message.nonce = reader.uint32();\n                        break;\n                    case 2:\n                        message.splitflapCommand = $root.PB.SplitflapCommand.decode(reader, reader.uint32());\n                        break;\n                    case 3:\n                        message.splitflapConfig = $root.PB.SplitflapConfig.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                    }\n                }\n                return message;\n            };\n    \n            /**\n             * Decodes a ToSplitflap message from the specified reader or buffer, length delimited.\n             * @function decodeDelimited\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @returns {PB.ToSplitflap} ToSplitflap\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ToSplitflap.decodeDelimited = function decodeDelimited(reader) {\n                if (!(reader instanceof $Reader))\n                    reader = new $Reader(reader);\n                return this.decode(reader, reader.uint32());\n            };\n    \n            /**\n             * Verifies a ToSplitflap message.\n             * @function verify\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {Object.<string,*>} message Plain object to verify\n             * @returns {string|null} `null` if valid, otherwise the reason why it is not\n             */\n            ToSplitflap.verify = function verify(message) {\n                if (typeof message !== \"object\" || message === null)\n                    return \"object expected\";\n                var properties = {};\n                if (message.nonce != null && message.hasOwnProperty(\"nonce\"))\n                    if (!$util.isInteger(message.nonce))\n                        return \"nonce: integer expected\";\n                if (message.splitflapCommand != null && message.hasOwnProperty(\"splitflapCommand\")) {\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.SplitflapCommand.verify(message.splitflapCommand);\n                        if (error)\n                            return \"splitflapCommand.\" + error;\n                    }\n                }\n                if (message.splitflapConfig != null && message.hasOwnProperty(\"splitflapConfig\")) {\n                    if (properties.payload === 1)\n                        return \"payload: multiple values\";\n                    properties.payload = 1;\n                    {\n                        var error = $root.PB.SplitflapConfig.verify(message.splitflapConfig);\n                        if (error)\n                            return \"splitflapConfig.\" + error;\n                    }\n                }\n                return null;\n            };\n    \n            /**\n             * Creates a ToSplitflap message from a plain object. Also converts values to their respective internal types.\n             * @function fromObject\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {Object.<string,*>} object Plain object\n             * @returns {PB.ToSplitflap} ToSplitflap\n             */\n            ToSplitflap.fromObject = function fromObject(object) {\n                if (object instanceof $root.PB.ToSplitflap)\n                    return object;\n                var message = new $root.PB.ToSplitflap();\n                if (object.nonce != null)\n                    message.nonce = object.nonce >>> 0;\n                if (object.splitflapCommand != null) {\n                    if (typeof object.splitflapCommand !== \"object\")\n                        throw TypeError(\".PB.ToSplitflap.splitflapCommand: object expected\");\n                    message.splitflapCommand = $root.PB.SplitflapCommand.fromObject(object.splitflapCommand);\n                }\n                if (object.splitflapConfig != null) {\n                    if (typeof object.splitflapConfig !== \"object\")\n                        throw TypeError(\".PB.ToSplitflap.splitflapConfig: object expected\");\n                    message.splitflapConfig = $root.PB.SplitflapConfig.fromObject(object.splitflapConfig);\n                }\n                return message;\n            };\n    \n            /**\n             * Creates a plain object from a ToSplitflap message. Also converts values to other types if specified.\n             * @function toObject\n             * @memberof PB.ToSplitflap\n             * @static\n             * @param {PB.ToSplitflap} message ToSplitflap\n             * @param {$protobuf.IConversionOptions} [options] Conversion options\n             * @returns {Object.<string,*>} Plain object\n             */\n            ToSplitflap.toObject = function toObject(message, options) {\n                if (!options)\n                    options = {};\n                var object = {};\n                if (options.defaults)\n                    object.nonce = 0;\n                if (message.nonce != null && message.hasOwnProperty(\"nonce\"))\n                    object.nonce = message.nonce;\n                if (message.splitflapCommand != null && message.hasOwnProperty(\"splitflapCommand\")) {\n                    object.splitflapCommand = $root.PB.SplitflapCommand.toObject(message.splitflapCommand, options);\n                    if (options.oneofs)\n                        object.payload = \"splitflapCommand\";\n                }\n                if (message.splitflapConfig != null && message.hasOwnProperty(\"splitflapConfig\")) {\n                    object.splitflapConfig = $root.PB.SplitflapConfig.toObject(message.splitflapConfig, options);\n                    if (options.oneofs)\n                        object.payload = \"splitflapConfig\";\n                }\n                return object;\n            };\n    \n            /**\n             * Converts this ToSplitflap to JSON.\n             * @function toJSON\n             * @memberof PB.ToSplitflap\n             * @instance\n             * @returns {Object.<string,*>} JSON object\n             */\n            ToSplitflap.prototype.toJSON = function toJSON() {\n                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n            };\n    \n            return ToSplitflap;\n        })();\n    \n        return PB;\n    })();\n\n    return $root;\n});\n"],"sourceRoot":""}